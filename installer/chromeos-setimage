#!/bin/sh -u
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# A script to display or change the preferred image

# Load functions and constants for chromeos-install.
. "$(dirname "$0")/chromeos-common.sh" || exit 1
if [ -e /usr/lib/shflags ]; then
  . /usr/lib/shflags || exit 1
else
  # In case we're being called from a mounted image.
  if [ -e "$(dirname "$0")"/../../usr/lib/shflags ]; then
    . "$(dirname "$0")"/../../usr/lib/shflags || exit 1
  else
    # Try to find it relative to src/scripts
    . ../third_party/shflags/files/src/shflags || exit 1
  fi
fi

# Default to using a verified root filesystem if the installer
# is verified.
rootfs_verification_default=${FLAGS_FALSE}
ignore_bad_verification_default=${FLAGS_TRUE}
if type rootdev &> /dev/null; then
  if rootdev | grep -qE '^/dev/(dm-|mapper/)'; then
    rootfs_verification_default=${FLAGS_TRUE}
    ignore_bad_verification_default=${FLAGS_FALSE}
  fi
fi

DEFINE_string dst "" "Boot device to update (Default: current root device)"
# Any time the verified boot flags change, this is needed
# as well as a new grub.cfg.
DEFINE_string update_syslinux_cfg "" \
  "If specified, the path to a syslinux root.[A|B].cfg."
DEFINE_string update_grub_cfg "" \
  "If specified, the path to a new grub.cfg."
DEFINE_string update_vmlinuz "" \
  "If specified, the path to a vmlinuz to use as syslinux's vmlinuz.[A|B]"
DEFINE_boolean run_as_root ${FLAGS_FALSE} \
  "Allow root to run this script (Careful, it won't prompt for a password!)"
DEFINE_boolean enable_rootfs_verification ${rootfs_verification_default} \
  "Default all bootloaders to use kernel-based root fs integrity checking."
DEFINE_string esp_mounted_at "" \
  "Specify a location if the esp has already been mounted"
DEFINE_string kernel_image "" \
  "Specifies a kernel image/partition to extract the configuration from. \
By default, it uses the kernel partition for A or B as requested."
DEFINE_string rootfs_image "" \
  "Specifies a rootfs image/partition to hash and update for vboot.
By default, it uses the current root device."
DEFINE_string install_root "/" \
  "Specifies the base location to find utilities in the new root"
DEFINE_boolean ignore_bad_verification ${ignore_bad_verification_default} \
  "Indicates if mismatched rootfs hashes will be ignored"

# Parse command line
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

set -e

INSTALL_ROOT="${FLAGS_install_root}"
# This export is so that locate_gpt will look within this install
# partition to find that copy of the cgpt program.
# TODO(wad,adlr) This duplicates the hack from postinst and should be fixed.
export DEFAULT_CHROOT_DIR="${INSTALL_ROOT}"
locate_gpt  # sets $GPT to cgpt executable

# Hack to run the code to setup the default dst only if not provided since if
# this is run from a mounted image on a different machine, rootdev will fail.
if [ -z "${FLAGS_dst}" ]; then
  # The default device is the one we booted from.
  ROOTDEV=$(rootdev)
  # From root partition to root block device.
  DEFAULT_DST=$(get_block_dev_from_partition_dev ${ROOTDEV})

  FLAGS_dst="${DEFAULT_DST}"
fi

# Validate args.
if [ -n "${@:-}" ]; then
  if [ "$1" = "0" ] || [ "$1" = "A" ] || [ "$1" = "a" ]; then
    newimg=0
    newimg_letter=A
  elif [ "$1" = "1" ] || [ "$1" = "B" ] || [ "$1" = "b" ]; then
    newimg=1
    newimg_letter=B
  else
    echo "Usage: $0 [A|B]" 1>&2
    exit 1
  fi
fi

# Don't run this as root
dont_run_as_root

# Check out the dst device.
if [ ! -b "$FLAGS_dst" ]
then
  echo "Error: Unable to find block device: $FLAGS_dst"
  exit 1
fi

# Setup loop devices so that we don't get burned by the kernel not knowing
# about updated partition changes.
ESP_LOOP=
ROOT_LOOP=
KERN_LOOP=

cleanup_loop() {
  local dev="$1"
  if [ -z "$dev" ]; then
    return 0
  fi
  (sudo umount "$dev" || true)
  (sudo losetup -d "$dev" || true)
}

cleanup() {
  cleanup_loop "${ESP_LOOP}"
  ESP_LOOP=
  cleanup_loop "${KERN_LOOP}"
  KERN_LOOP=
  cleanup_loop "${ROOT_LOOP}"
  ROOT_LOOP=

  # Failing to clean this up isn't the worst.
  if [ -n "${ESP_TMP_DIR}" ]; then
    rmdir "${ESP_TMP_DIR}" || true
  fi

  rm -f ${tempfile} || true
}

setup_dst_loop() {
  local part="$1"
  local dev=$(sudo losetup -f)
  if [ -z "$dev" ]; then
    echo "No free loop devices." 1>&2
    return 1
  fi
  local offset=$(partoffset ${FLAGS_dst} $part)
  local size=$(partsize ${FLAGS_dst} $part)
  sudo losetup -o $((512 * offset)) \
               --sizelimit $((512 * size)) \
               ${dev} \
               ${FLAGS_dst}
  echo $dev
}

ESP_TMP_DIR=
tempfile=$(mktemp /tmp/grubcfg_XXXXXXXXX)
trap cleanup EXIT

# Mount the EFI System Partition
mountpoint="${FLAGS_esp_mounted_at}"
if [ -z "${mountpoint}" ]; then
  mountpoint=$(mktemp -d  /tmp/mountesp_XXXXXXXXX)
  ESP_TMP_DIR=${mountpoint}
  ESP_LOOP=$(setup_dst_loop 12)
  sudo mount ${ESP_LOOP} ${mountpoint}
fi

if [ -n "$FLAGS_update_syslinux_cfg" -a ! -r "$FLAGS_update_syslinux_cfg" ];
then
  echo "Specified syslinux root cfg file not found."
  exit 1
fi

# Re-hash the root filesystem and use the table for dm-verity.
# We extract the parameters for verification from the kernel
# partition, but we regenerate and reappend the hash tree to
# keep the updater from needing to manage them explicitly.
# Instead, rootfs integrity will be validated on next boot through
# the verified kernel configuration.
selected_kernel=$(( (newimg + 1) * 2))  # part 2 or 4
kernel_image="${FLAGS_kernel_image}"
if [ -z "${FLAGS_kernel_image}" ]; then
  KERN_LOOP=$(setup_dst_loop ${selected_kernel})
  kernel_image="${KERN_LOOP}"
fi

# Grab the contents of dm="" and trim off the preamble.
DUMP_KERNEL_CONFIG="${INSTALL_ROOT}"/usr/bin/dump_kernel_config
kernel_cfg="$(sudo "${DUMP_KERNEL_CONFIG}" ${kernel_image} |
              sed -e 's/.*dm="\([^"]*\)".*/\1/g' |
              cut -f2- -d,)"
rootfs_sectors=$(echo ${kernel_cfg} | cut -f2 -d' ')
verity_depth=$(echo ${kernel_cfg} | cut -f7 -d' ')
verity_algorithm=$(echo ${kernel_cfg} | cut -f8 -d' ')

selected_root=$((selected_kernel + 1))
rootfs_image="${FLAGS_rootfs_image}"
if [ -z "${rootfs_image}" ]; then
  ROOT_LOOP=$(setup_dst_loop ${selected_root})
  rootfs_image="${ROOT_LOOP}"
fi

# Compute the rootfs hash tree and dump it in the tempfile.
# TODO(wad) take preamble from dump_kernel_config.
VERITY="${INSTALL_ROOT}"/bin/verity
table="vroot none ro,"$(sudo "${VERITY}" create \
        ${verity_depth} \
        "${verity_algorithm}" \
        "${rootfs_image}" \
        $((rootfs_sectors / 8)) \
        ${tempfile})

expected_hash=$(echo ${kernel_cfg} | cut -f9 -d' ')
generated_hash=$(echo ${table} | cut -f2- -d, | cut -f9 -d' ')

if [ "${expected_hash}" != "${generated_hash}" ]; then
  echo "Root filesystem has been modified unexpectedly!" 1>&2
  if [ ${FLAGS_ignore_bad_verification} -eq ${FLAGS_FALSE} ]; then
    exit 1
  fi
fi

if [ -n "${newimg:-}" ]; then
  # This will usually be ${rootfs_image} except for cases where
  # FLAGS_dst and FLAGS_rootfs_image diverge.
  dst_part=$(make_partition_dev ${FLAGS_dst} ${selected_root})
  # Replace the placeholders from the verity tool.
  table="$(echo "$table" |
           sed -s "s|ROOT_DEV|${dst_part}|g;s|HASH_DEV|${dst_part}|g")"
fi
# Overwrite the appended hashes with the new ones.
sudo dd if=${tempfile} of="${rootfs_image}" \
        bs=512 seek=${rootfs_sectors} conv=notrunc

# Make the change
if [ -n "${newimg:-}" ]; then
  grubid=${newimg}
  test ${FLAGS_enable_rootfs_verification} -eq ${FLAGS_TRUE} && \
    grubid=$((newimg+2))
  if [ -z "$FLAGS_update_grub_cfg" ]; then
    FLAGS_update_grub_cfg=${mountpoint}/efi/boot/grub.cfg
  fi
  echo "Updating the verified boot config and grub boot default: $grubid"
  sed -e "s/^set default=.*/set default=${grubid}/" \
      -e "s|DMTABLE${newimg_letter}|${table}|g" \
    $FLAGS_update_grub_cfg > ${tempfile}
  # TODO(wad) Break grub.cfg into multiple files if possible.
  #   Because grub.cfg is monolithic when we update from a templated
  #   copy, the inactive image will be unpopulated since we do this
  #   once per call to setimage.

  sudo cp ${tempfile} ${mountpoint}/efi/boot/grub.cfg
fi

# Rinse and repeat for the Legacy BIOS bootloader (syslinux)
if [ -n "${newimg:-}" ]; then
  echo "Updating default syslinux target to $newimg"
  target_hd=chromeos-hd
  test ${FLAGS_enable_rootfs_verification} -eq ${FLAGS_TRUE} && \
    target_hd=chromeos-vhd

  echo "DEFAULT ${target_hd}.${newimg_letter}" > ${tempfile}
  sudo cp ${tempfile} ${mountpoint}/syslinux/default.cfg

  vmlinuz_tgt=${mountpoint}/syslinux/vmlinuz.${newimg_letter}
  syslinux_root_cfg=${mountpoint}/syslinux/root.${newimg_letter}.cfg

  # Update the root.X.cfg in place if none given.
  # Note that the replacement variables may not be intact.
  if [ -z "$FLAGS_update_syslinux_cfg" ]; then
      FLAGS_update_syslinux_cfg=$syslinux_root_cfg
  fi

  # 3 and 5 are the current rootfs a and b partitions
  DST_PART_A=$(make_partition_dev ${FLAGS_dst} 3)
  DST_PART_B=$(make_partition_dev ${FLAGS_dst} 5)
  sed -e "s|HDROOTA|${DST_PART_A}|g;s|HDROOTB|${DST_PART_B}|g" \
      -e "s|DMTABLEA|${table}|g;s|DMTABLEB|${table}|g" \
    $FLAGS_update_syslinux_cfg > ${tempfile}
  # Even though we replace both A and B, we're only updating the file
  # that is relevant to the setimage request so we won't put an invalid
  # value for the old root nor will the old root.cfg be broken.
  sudo cp ${tempfile} $syslinux_root_cfg

  # We only need to do this for syslinux since grub can read the rootfs.
  if [ -n "$FLAGS_update_vmlinuz" ]; then
    echo "Updating vmlinuz..."
    sudo cp -fL "$FLAGS_update_vmlinuz" "$vmlinuz_tgt"
  fi
fi

set +e  # just grep oneliners and cleanup from here on out.

echo "Current EFI boot default is:"
# Print the [new] default choice
grep -qs '^set default=0' ${mountpoint}/efi/boot/grub.cfg && echo "A"
grep -qs '^set default=1' ${mountpoint}/efi/boot/grub.cfg && echo "B"
grep -qs '^set default=2' ${mountpoint}/efi/boot/grub.cfg && echo "A (verified)"
grep -qs '^set default=3' ${mountpoint}/efi/boot/grub.cfg && echo "B (verified)"

echo "Current legacy boot default is:"
# Print the [new] default choice
grep -qs 's-hd\.A$' ${mountpoint}/syslinux/default.cfg && echo "A"
grep -qs 's-hd\.B$' ${mountpoint}/syslinux/default.cfg && echo "B"
grep -qs 'vhd\.A$' ${mountpoint}/syslinux/default.cfg && echo "A (verified)"
grep -qs 'vhd\.B$' ${mountpoint}/syslinux/default.cfg && echo "B (verified)"

exit 0
