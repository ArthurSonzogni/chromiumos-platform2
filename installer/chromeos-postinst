#!/bin/sh

# Copyright (c) 2009 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script is called after an AutoUpdate or USB install. The first argument
# is the partition where the new rootfs is installed or empty. If non-empty
# the rootfs should be updated w/ the new bootloader config. If empty, the
# rootfs is mounted-read only and should not be updated.

# Setup INSTALL_ROOT
INSTALL_ROOT=$(dirname "$0")
# Load helper functions
. "${INSTALL_ROOT}"/usr/sbin/chromeos-common.sh
. "${INSTALL_ROOT}"/usr/lib/shflags

# Process flags now, couldn't earlier since we needed INSTALL_ROOT
# to know where to load shflags from
DEFINE_string esp_part_file "" "File containing the ESP partition"
DEFINE_boolean postcommit ${FLAGS_FALSE} "Run postcommit"

# WARNING: do NOT change this default value without consulting adlr/nsanders.
# If you want to temporary enable firmware update for testing, create a
# tag file in ${INSTALL_ROOT}/root/.force_update_firmware
FLAGS_firmware_default=${FLAGS_FALSE}
if [ -f "${INSTALL_ROOT}/root/.force_update_firmware" ]; then
  FLAGS_firmware_default=${FLAGS_TRUE}
fi
DEFINE_boolean update_firmware $FLAGS_firmware_default "Enable firmware update."
DEFINE_boolean debug ${FLAGS_FALSE} "Show debug output. Default: false"

# Parse command line
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"
set -e

SUB_CMD_DEBUG_FLAG=""
if [ "$FLAGS_debug" -eq "${FLAGS_TRUE}" ]; then
  set -x
  SUB_CMD_DEBUG_FLAG="--debug"
fi

# Update syslinux configuration file and install syslinux itself.
INSTALL_DEV="$1"

# Find whole disk device.
ROOT_DEV=$(get_block_dev_from_partition_dev ${INSTALL_DEV})
NEW_PART_NUM=${INSTALL_DEV##*/*[a-z]}

case ${NEW_PART_NUM} in
  "3" )
    BOOT_SLOT="A"
    ;;
  "5" )
    BOOT_SLOT="B"
    ;;
  * )
    # Not a valid boot location.
    echo "Not a valid target parition number: ${NEW_PART_NUM}"
    exit 1
    ;;
esac
# For legacy and efi boot, we only have one boot-capable partition.
LEGACY_PART_NUM=12

if [ "${FLAGS_postcommit}" -eq "${FLAGS_FALSE}" ]; then
  # Pre-commit. Returning an error here will prevent ever booting into the
  # installed system.

  echo "Postinst running"

  # If this FS was mounted read-write, we can't do deltas from it. Mark the
  # FS as such
  (touch "${INSTALL_ROOT}/.nodelta" || true) > /dev/null 2>&1

  echo " Set boot target to ${INSTALL_DEV}: \
Partition ${NEW_PART_NUM}, Slot ${BOOT_SLOT}"

  # TODO(rkc): This is a bit of a hack - we're depending on the fact that our
  # build machine will always be Intel based - if it isn't, VM builds will fail
  IS_INTEL_ARCH=$(uname -m | grep "^i.86\|^x86_..\$" | wc -l)
  # Install syslinux files on EFI partition
  if [ -z "${IS_INSTALL}" -a "${IS_INTEL_ARCH}" -eq "1" ]; then
    EFI_MNT=$(mktemp -d /tmp/EFI.XXXXXX)
    if [ -z "${FLAGS_esp_part_file}" ]; then
      EFI_PART=$(make_partition_dev "${ROOT_DEV}" "${LEGACY_PART_NUM}")
    else
      EFI_PART=$(losetup -f)
      if [ -z "${EFI_PART}" ]; then
        # It's okay to die here; this parameter will never be given on live
        # system - this is only in case of mounted image postinst runs
        die "No free loop device. Free up a loop device or reboot. Exiting."
      fi
      losetup "${EFI_PART}" "${FLAGS_esp_part_file}"
    fi
    # TODO: scary hack to work around disk corruption
    # Note, we mean to run fsck.vfat twice, fsck.vfat returns status 1 for
    # "Recoverable errors have been detected or dosfsck has discovered an
    # internal inconsistency."  If the first fsck fixes errors the first time,
    # the second fsck will succeed.  Otherwise, nuke it from orbit.
    if ! "${INSTALL_ROOT}/sbin/fsck.vfat" -a "${EFI_PART}"; then
      if ! "${INSTALL_ROOT}/sbin/fsck.vfat" -a "${EFI_PART}"; then
        echo "Rebuilding FAT filessytem."
        "${INSTALL_ROOT}/usr/sbin/mkfs.vfat" "${EFI_PART}"
      fi
    fi
    mount "${EFI_PART}" "${EFI_MNT}"
    set +e
    # Copy over the templates, but don't clobber anything.
    # Clobbering is boot_slot specific and handled by setimage below.
    cp -nR "${INSTALL_ROOT}"/boot/syslinux "${EFI_MNT}"
    ERR=${?}
    echo "Updating syslinux"
    # Update all legacy bootloaders.
    if [ "${ERR}" -eq "0" ]; then
      syslinux_cfg="${INSTALL_ROOT}/boot/syslinux/root.${BOOT_SLOT}.cfg"
      grub_cfg="${INSTALL_ROOT}/boot/efi/boot/grub.cfg"
      "${INSTALL_ROOT}"/usr/sbin/chromeos-setimage ${BOOT_SLOT} \
          --dst=${ROOT_DEV} --run_as_root \
          --install_root="${INSTALL_ROOT}" \
          --update_syslinux_cfg="${syslinux_cfg}" \
          --update_grub_cfg="${grub_cfg}" \
          --esp_mounted_at="${EFI_MNT}" \
          --update_vmlinuz=${INSTALL_ROOT}/boot/vmlinuz \
          ${SUB_CMD_DEBUG_FLAG}
      ERR=${?}
    fi
    umount "${EFI_MNT}"
    rmdir "${EFI_MNT}"
    if [ "${ERR}" -ne "0" ]; then
      echo "Failed to copy syslinux files in and make them bootable."
      exit 1
    fi
    set -e
    mount -o bind /dev "${INSTALL_ROOT}"/dev
    set +e
    mount -o bind /proc "${INSTALL_ROOT}"/proc
    ERR=${?}
    if [ "${ERR}" -ne "0" ]; then
      umount "${INSTALL_ROOT}"/dev
      echo "Failed to bind mount /proc"
      exit 1
    fi
    mount -o bind /tmp "${INSTALL_ROOT}"/tmp
    ERR=${?}
    if [ "${ERR}" -ne "0" ]; then
      umount "${INSTALL_ROOT}"/dev
      umount "${INSTALL_ROOT}"/proc
      echo "Failed to bind mount /tmp"
      exit 1
    fi
    chroot "${INSTALL_ROOT}" /usr/bin/syslinux "${EFI_PART}"
    ERR=${?}
    umount "${INSTALL_ROOT}"/tmp
    umount "${INSTALL_ROOT}"/proc
    umount "${INSTALL_ROOT}"/dev
    if (expr match "${EFI_PART}" "/dev/loop*" >/dev/null); then
      losetup -d "${EFI_PART}"
    fi
    set -e
    if [ "${ERR}" -ne "0" ]; then
      echo "Failed to run syslinux on: ${EFI_PART}"
      exit 1
    fi
  fi

  # This export is so that locate_gpt will look within this install
  # partition to find that copy of the cgpt program.
  # Note, this only works when running $INSTALL_ROOT/postinst.
  export DEFAULT_CHROOT_DIR=$(dirname "$0")
  locate_gpt  # sets $GPT to cgpt executable

  # If we're working on a real machine, not a mounted image, only then
  # run the gpt tool to manipulate the partitions - if we're touching
  # the ESP from a file, it means we are not on the target hardware, making
  # the GPT and firmware scripts inapplicable nor are we auto-updating
  if [ -z "${FLAGS_esp_part_file}" ]; then
    echo "Updating the root filesystem hashes and legacy bootloaders"
    # Ensure we use a template from the INSTALL_ROOT for both grub
    # and syslinux otherwise we can never update them with new rootfs
    # vboot configuration data.
    syslinux_cfg="${INSTALL_ROOT}/boot/syslinux/root.${BOOT_SLOT}.cfg"
    grub_cfg="${INSTALL_ROOT}/boot/efi/boot/grub.cfg"
    "${INSTALL_ROOT}"/usr/sbin/chromeos-setimage ${BOOT_SLOT} \
        --dst=${ROOT_DEV} --run_as_root \
        --install_root="${INSTALL_ROOT}" \
        --update_syslinux_cfg="${syslinux_cfg}" \
        --update_grub_cfg="${grub_cfg}" \
        --update_vmlinuz=${INSTALL_ROOT}/boot/vmlinuz \
        ${SUB_CMD_DEBUG_FLAG}

    echo "Updating Partition Table Attributes..."
    # Mark partition table to indicate an update has occurred.
    # The updated partition should have the highest priority (priority=3) so it
    # will be tried on the next reboot.
    # The updated partition should have its success flag marked 0 and its tries
    # flag marked as having 3 attempts remaining unless in factory installation
    # or recovery (USB) mode (nothing to fallback for these modes)
    # The partition that has the highest priority before the update should have
    # the highest priority after the updated kernel (priority=2).
    # All other enabled kernel partitions are assigned priority=1.
    # Kernel partitions that were disabled (priority=0) should remain disabled.
    kern_parts=""
    all_parts="$ROOT_DEV"*
    NEW_KERN_NUM=$(( $NEW_PART_NUM - 1))
    # Find all kernel partitions
    for i in $all_parts
    do
        current_index=${i##*/*[a-z]}
        # Necessary check on arm where device is formatted mmcblk[0-9]p[0-9]
        if [ -z "$current_index" ] || [ "$current_index" -eq 0 ]; then
          continue
        fi
        # Get type string for current partition
        type=`"$GPT" show -i $current_index -t $ROOT_DEV`
        # Check if type string indicates that it is a kernel partition
        if [ "$type" = "FE3A2A5D-4F32-41A7-B725-ACCC3285A309" ]; then
          kern_parts="$current_index $kern_parts"
        fi
    done
    highest_prio=0
    highest_prio_index=-1
    # Mark all kernel partitions low priority
    # Kernels with priority zero should not be changed
    for i in $kern_parts
    do
        # Get priority (a number) of the current partition
        current_prio=`"$GPT" show -i $i -P $ROOT_DEV`
        if [ $current_prio -eq 0 ]; then
          continue
        fi
        if [ "$current_prio" -gt "$highest_prio" ]; then
          if [ "$i" != $NEW_KERN_NUM ]; then
            highest_prio=$current_prio
            highest_prio_index=$i
          fi
        fi
        "$GPT" add -i $i -P 1 $ROOT_DEV
    done
    # The kernel with the highest priority should retain its higher priority
    if [ $highest_prio != 0 ]; then
        "$GPT" add -i $highest_prio_index -P 2 $ROOT_DEV
    fi
    # set kernel as successful=1 except when autoupdating
    new_as_successful=0
    if [ -n "${IS_FACTORY_INSTALL}" -o \
         -n "${IS_RECOVERY_INSTALL}" -o \
         -n "${IS_INSTALL}" ]; then
      new_as_successful=1
    fi
    # Make updated partition highest priority for next reboot
    sudo "$GPT" add -i $NEW_KERN_NUM -P 3 -S $new_as_successful -T 3 $ROOT_DEV

    # Set up gpt boot selection for legacy devices.
    # flush linux caches; seems to be necessary
    sync
    echo 3 > /proc/sys/vm/drop_caches

    echo "Updating gpt PMBR target for legacy BIOS"
    # Configure the PMBR to boot the new image.
    #
    # IMPORTANT NOTE: postinst is run by the previoulsy installed image
    # rather than the new image. So changes here need to be backwards compatible
    # with the old image's gpt binaries.
    #
    if [ -x /usr/bin/cgpt ]; then
      echo "marking part $LEGACY_PART_NUM bootable (new)"
      cgpt boot -i $LEGACY_PART_NUM ${ROOT_DEV} 2>&1
    else
      # The old gpt tool requires a -b arg to specify the PMBR bootcode.
      # We don't want to change the code, so we have to extract it,
      # then put it back.
      dd if=${ROOT_DEV} bs=512 count=1 of=/tmp/oldpmbr.bin
      echo "marking part $LEGACY_PART_NUM bootable (old)"
      gpt -S boot -i $LEGACY_PART_NUM -b /tmp/oldpmbr.bin ${ROOT_DEV} 2>&1
    fi

    # At this point in the script, the new partition has been marked bootable
    # and a reboot will boot into it. Thus, it's important that any future
    # errors in this script do not cause this script to return failure unless
    # in factory mode.
    if [ -z "${IS_FACTORY_INSTALL}" ]; then
      set +e
    fi

    # See if we need to update firmware. NOTE: we must activate new firmware
    # only after new kernel is actived (installed and made bootable),
    # otherwise new firmware with all old kernels may lead to recovery screen
    # (due to new key).
    FIRMWARE_UPDATE_SCRIPT="${INSTALL_ROOT}/usr/sbin/chromeos-firmwareupdate"
    if [ ${FLAGS_update_firmware} -eq "${FLAGS_TRUE}" -a \
         -x "${FIRMWARE_UPDATE_SCRIPT}" ]; then
      FIRMWARE_UPDATE_MODE=""
      if [ -n "${IS_FACTORY_INSTALL}" ]; then
        # factory-mode
        FIRMWARE_UPDATE_MODE="--factory"
      elif [ -n "${IS_RECOVERY_INSTALL}" ]; then
        # recovery-mode
        FIRMWARE_UPDATE_MODE="--rw-ab-together"
      elif [ -n "${IS_INSTALL}" ]; then
        # installation from chromeos-install
        FIRMWARE_UPDATE_MODE="--rw-ab-together"
      else
        # Default: background update by Update Engine.
        # "--background-update" tells it not to perform any dangerous
        # thing that would require/cause reboot, for example re-writing
        # EC firmware. Those tasks will be done in next boot.
        FIRMWARE_UPDATE_MODE="--background-update"
      fi
      FIRMWARE_UPDATE_ARGS=" $FIRMWARE_UPDATE_MODE "
      echo "Updating firmware ($FIRMWARE_UPDATE_ARGS)"
      env INSTALL_ROOT="${INSTALL_ROOT}" \
        "${FIRMWARE_UPDATE_SCRIPT}" ${FIRMWARE_UPDATE_ARGS}
      # Next step after postinst may take a lot of time (eg, disk wiping)
      # and people may confuse that as 'firmware update takes a long wait',
      # we explicitly prompt here.
      if [ "$?" -eq 0 ]; then
        echo "Firmware update complete."
      else
        echo "Firmware update failed."
        if [ -n "${IS_FACTORY_INSTALL}" ];
          echo "Aborting on firmware update failure during factory install"
          exit 1
        fi
      fi
    fi
  fi
else
  # Post-commit. At this point an unexpected reboot may boot the installed
  # system, but returning an error here will cause the updater to try to
  # not boot the installed system, instead keeping the existing system.
  echo -n  # this is a noop, required for 'sh'

  # We are deprecating post-commit postinst, so do not put anything in here.

  echo "Updating gpt PMBR target for legacy BIOS (post-commit)"
  # I know we aren't supposed to put anything here, but here is the
  # justification:
  # The updater in 0.7.42.* sets the rootfs bootable after postinst (precommit)
  # is run, and then runs postinst (postcommit). Later versions of the updater
  # neither mark partitions bootable, nor run postinst (postcommit). In those
  # newer versions, this code won't be run, but it won't need to be run.
  # If we didn't care about clients as old as 0.7.42.*, we could leave this
  # area empty. Unfortunately, we can't update old updaters.

  # At some point, when we don't care about clients that old (0.7.42.*),
  # We should remove this whole code path in this file.


  if [ -x "${INSTALL_ROOT}"/usr/bin/cgpt ]; then
    echo "marking part $LEGACY_PART_NUM bootable (new)"
    "${INSTALL_ROOT}"/usr/bin/cgpt boot -i $LEGACY_PART_NUM ${ROOT_DEV} 2>&1
  else
    # The old gpt tool requires a -b arg to specify the PMBR bootcode. We don't
    # want to change the code, so we have to extract it, then put it back.
    dd if=${ROOT_DEV} bs=512 count=1 of=/tmp/oldpmbr.bin
    echo "marking part $LEGACY_PART_NUM bootable (old)"
    gpt -S boot -i $LEGACY_PART_NUM -b /tmp/oldpmbr.bin ${ROOT_DEV} 2>&1
  fi
fi
