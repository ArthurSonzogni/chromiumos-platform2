#!/bin/sh -u
# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# A script to install from removable media to hard disk.

# Load functions and constants for chromeos-install.
. "$(dirname "$0")/chromeos-common.sh" || exit 1
. /usr/lib/shflags || exit 1

MACHINE_NAME=$(uname -m)
if [ "${MACHINE_NAME}" = "armv7l" ]; then
  DEFAULT_DST=/dev/mmcblk0
else
  DEFAULT_DST=/dev/sda
fi

DEFINE_string dst "${DEFAULT_DST}" "Destination device"
DEFINE_boolean skip_src_removable ${FLAGS_FALSE} \
  "Skip check to ensure source is removable"
DEFINE_boolean skip_rootfs ${FLAGS_FALSE} \
  "Skip installing the rootfs; Only set up partition table"
DEFINE_boolean run_as_root ${FLAGS_FALSE} \
  "Allow root to run this script (Careful, it won't prompt for a password!)"
DEFINE_boolean yes ${FLAGS_FALSE} \
  "Answer yes to everything"
DEFINE_boolean skip_vblock ${FLAGS_FALSE} \
  "Skip copying the HD vblock to install destination. Default: False"
DEFINE_boolean preserve_stateful ${FLAGS_FALSE} \
  "Don't create a new filesystem for the stateful partition. Be careful \
using this option as this may make the stateful partition not mountable. \
Default: False."
DEFINE_string payload_image "" "Path to a Chromium OS image to install onto \
the device's hard drive. Default: (empty)."


# Parse command line
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

set -e

# Don't run this as root
dont_run_as_root

# Find root partition of the block device that we are installing from
get_root_device() {
  local root_dev=$(rootdev)
  local on_dm=0

  # If we're on a verified rootfs, the rootdev won't be meaningful.
  if echo "${root_dev}" | grep -q '^/dev/mapper/'; then
    on_dm=1
  fi
  if [ "${root_dev}" = "/dev/dm-0" ]; then
    on_dm=1
  fi
  if [ "${on_dm}" -eq "1" ]; then
    root_dev="/dev/$(basename /sys/block/dm-0/slaves/*)"
  fi
  echo $root_dev
}

# Check for optional payload image
if [ -z "$FLAGS_payload_image" ]; then
  # Find root partition of the root block device
  SRC=$(get_block_dev_from_partition_dev $(get_root_device))

  if [ "$FLAGS_skip_src_removable" -eq "${FLAGS_FALSE}" ]; then
    if [ "$(cat /sys/block/${SRC#/dev/}/removable)" != "1" ]; then
      echo "Error: Source does not look like a removable device: $SRC"
      exit 1
    fi
  fi
else
  if [ -f "$FLAGS_payload_image" ]; then
    SRC=$FLAGS_payload_image  # Needed to copy PMBR code off image
  else
    echo "Error: No payload image found at $FLAGS_payload_image"
    exit 1
  fi
fi

# Check out the dst device.
if [ ! -b "$FLAGS_dst" ]; then
  echo "Error: Unable to find destination block device: $FLAGS_dst"
  exit 1
fi

DST_REMOVABLE=$(cat /sys/block/${FLAGS_dst#/dev/}/removable)
if [ $? -ne 0 ]; then
  echo "Error: Invalid destination device (must be whole device): $FLAGS_dst"
  exit 1
fi

if [ "$DST_REMOVABLE" != "0" ]; then
  echo "Error: Attempt to install to a removeable device: $FLAGS_dst"
  exit 1
fi

if [ "$FLAGS_dst" = "$SRC" ]; then
  echo "Error: src and dst the same: $SRC = $FLAGS_dst"
  exit 1
fi

# Ask for root password to be sure.
echo "This will install from '$SRC' to '$FLAGS_dst'. If you are sure this is"
echo "what you want then feel free to enter the root password to proceed."
sudo -K

echo "This will erase all data at this destination: $FLAGS_dst"
if [ "${FLAGS_yes}" -eq "$FLAGS_FALSE" ]; then
  read -p "Are you sure (y/N)? " SURE
  if [ "$SURE" != "y" ]; then
    echo "Ok, better safe than sorry; you answered '$SURE'."
    exit 1
  fi
fi

##############################################################################
# Helpful constants and functions.

PMBRCODE=/tmp/gptmbr.bin
TMPFILE=/tmp/install-temp-file
TMPMNT=/tmp/install-mount-point
mkdir -p ${TMPMNT}

# Create a loop device on the given file at a specified (sector) offset.
# Remember the loop device using the global variable LOOP_DEV.
# Invoke as: command
# Args: FILE OFFSET
loop_offset_setup() {
  local filename=$1
  local offset=$2

  LOOP_DEV=$(sudo losetup -f)
  if [ -z "$LOOP_DEV" ]
  then
    echo "No free loop device. Free up a loop device or reboot. Exiting."
    exit 1
  fi

  sudo losetup -o $(($offset * 512)) ${LOOP_DEV} ${filename}
}

# Delete the current loop device.
loop_offset_cleanup() {
  # losetup -a doesn't always show every active device, so we'll always try to
  # delete what we think is the active one without checking first. Report
  # success no matter what.
  sudo losetup -d ${LOOP_DEV} || /bin/true
}

# Mount the existing loop device at the mountpoint in $TMPMNT.
# Args: optional 'readwrite'. If present, mount read-write, otherwise read-only.
mount_on_loop_dev() {
  local rw_flag=${1-readonly}
  local mount_flags=""
  if [ "${rw_flag}" != "readwrite" ]; then
    mount_flags="-o ro"
  fi
  sudo mount ${mount_flags} ${LOOP_DEV} ${TMPMNT}
}

# Unmount loop-mounted device.
umount_from_loop_dev() {
  mount | grep -q " on ${TMPMNT} " && sudo umount ${TMPMNT}
}

# Undo both mount and loop.
my_cleanup() {
  umount_from_loop_dev
  loop_offset_cleanup
}

##############################################################################

KERNEL_IMG_OFFSET=0
ROOTFS_IMG_OFFSET=0
OEM_IMG_OFFSET=0
ESP_IMG_OFFSET=0

# What do we expect & require to have on the source device?
if [ -z "$FLAGS_payload_image" ]; then
  STATEFUL_IMG=$(make_partition_dev ${SRC} 1)
  KERNEL_IMG=$(make_partition_dev ${SRC} 2)
  ROOTFS_IMG=$(make_partition_dev ${SRC} 3)
  OEM_IMG=$(make_partition_dev ${SRC} 8)
  ESP_IMG=$(make_partition_dev ${SRC} 12)

  STATEFUL_IMG_SECTORS=$(numsectors $STATEFUL_IMG)
  KERNEL_IMG_SECTORS=$(numsectors $KERNEL_IMG)
  ROOTFS_IMG_SECTORS=$(numsectors $ROOTFS_IMG)
  OEM_IMG_SECTORS=$(numsectors $OEM_IMG)
  ESP_IMG_SECTORS=$(numsectors $ESP_IMG)
else
  KERNEL_IMG=${FLAGS_payload_image}
  ROOTFS_IMG=${FLAGS_payload_image}
  OEM_IMG=${FLAGS_payload_image}
  ESP_IMG=${FLAGS_payload_image}

  locate_gpt
  STATEFUL_IMG_SECTORS=$(partsize "${FLAGS_payload_image}" 1)
  KERNEL_IMG_SECTORS=$(partsize "${FLAGS_payload_image}" 2)
  ROOTFS_IMG_SECTORS=$(partsize "${FLAGS_payload_image}" 3)
  OEM_IMG_SECTORS=$(partsize "${FLAGS_payload_image}" 8)
  ESP_IMG_SECTORS=$(partsize "${FLAGS_payload_image}" 12)

  KERNEL_IMG_OFFSET=$(partoffset "${FLAGS_payload_image}" 2)
  ROOTFS_IMG_OFFSET=$(partoffset "${FLAGS_payload_image}" 3)
  OEM_IMG_OFFSET=$(partoffset "${FLAGS_payload_image}" 8)
  ESP_IMG_OFFSET=$(partoffset "${FLAGS_payload_image}" 12)
fi

if [ "$MACHINE_NAME" = "armv7l" ]; then
  PMBRCODE=/dev/zero
else
  # Steal the PMBR code from the source MBR to put on the dest MBR, for booting
  # on legacy-BIOS devices.
  sudo dd if=$SRC of=$PMBRCODE bs=512 count=1
fi

# Create the GPT.
install_gpt ${FLAGS_dst} ${ROOTFS_IMG_SECTORS} ${STATEFUL_IMG_SECTORS} \
  ${PMBRCODE} ${ESP_IMG_SECTORS}

# TODO(tgao): add support for arm recovery
if [ "$MACHINE_NAME" = "armv7l" ]; then
  DEVICE=$(echo $FLAGS_dst | sed -e 's/^.*\([0-9]\)$/\1/')
  MBR_SCRIPT_UIMG=$(make_arm_mbr ${START_KERN_A} ${NUM_KERN_SECTORS} ${DEVICE} "")
  sudo dd bs=1 count=`stat --printf="%s" ${MBR_SCRIPT_UIMG}` \
     if="$MBR_SCRIPT_UIMG" of=${FLAGS_dst} conv=notrunc
fi

if [ "$FLAGS_skip_rootfs" -eq "$FLAGS_TRUE" ]; then
  echo Done installing partitons.
  exit 0
fi

# Install the content.
echo "Copying kernel..."
sudo dd if=${KERNEL_IMG} of=${FLAGS_dst} conv=notrunc bs=512 \
  seek=${START_KERN_A} skip=${KERNEL_IMG_OFFSET} count=${KERNEL_IMG_SECTORS}
sudo dd if=${KERNEL_IMG} of=${FLAGS_dst} conv=notrunc bs=512 \
  seek=${START_KERN_B} skip=${KERNEL_IMG_OFFSET} count=${KERNEL_IMG_SECTORS}

# Copy kernel verification block to target HD
copy_kernel_vblock() {
  local ret=0

  if [ -s $VERIFY_BLOB ]; then
    sudo dd if=${VERIFY_BLOB} of=${FLAGS_dst} \
      conv=notrunc bs=512 seek=${START_KERN_A}
    sudo dd if=${VERIFY_BLOB} of=${FLAGS_dst} \
      conv=notrunc bs=512 seek=${START_KERN_B}
    ret=1
  fi
  echo ${ret}
}

# The recovery image is signed with different keys from the hard-disk image. We
# need to copy the hard disk verification block from the stateful partition so
# that reboot from HD can be verified.
VERIFY_BLOB="/mnt/stateful_partition/vmlinuz_hd.vblock"
if [ "$FLAGS_skip_vblock" -eq "$FLAGS_FALSE" ]; then
  if [ -z "$FLAGS_payload_image" ]; then
    VBLOCK_RET=$(copy_kernel_vblock)
  else
    # Special handling of stateful partition, mount to loop device so that we
    # can extract kernel vblock to copy to target HD
    loop_offset_setup ${FLAGS_payload_image} \
                      $(partoffset "${FLAGS_payload_image}" 1)
    trap loop_offset_cleanup EXIT
    mount_on_loop_dev
    trap my_cleanup EXIT
    VERIFY_BLOB=${TMPMNT}/vmlinuz_hd.vblock
    VBLOCK_RET=$(copy_kernel_vblock)
    umount_from_loop_dev
    trap loop_offset_cleanup EXIT
    loop_offset_cleanup
    trap - EXIT
  fi

  if [ "${VBLOCK_RET}" -eq "1" ]; then
    echo "Copied kernel verification blob from ${VERIFY_BLOB}"
  else
    echo "Error: kernel verification blob not found in stateful partition"
    exit 1
  fi
fi

echo "Copying rootfs..."
# We can no longer update the label on the rootfs because that changes bits
# that will break both the delta updater and verified boot.  We must do a
# straight copy now.  The GPT labels and UUIDs are the only mutable naming
# areas we have after a build.
sudo dd if=${ROOTFS_IMG} of=${FLAGS_dst} conv=notrunc bs=512 \
        seek=${START_ROOTFS_A} skip=${ROOTFS_IMG_OFFSET} \
        count=${ROOTFS_IMG_SECTORS}
sudo dd if=${ROOTFS_IMG} of=${FLAGS_dst} conv=notrunc bs=512 \
        seek=${START_ROOTFS_B} skip=${ROOTFS_IMG_OFFSET} \
        count=${ROOTFS_IMG_SECTORS}

echo "Copying OEM customization..."
sudo dd if=${OEM_IMG} of=${FLAGS_dst} conv=notrunc bs=512 seek=${START_OEM} \
        skip=${OEM_IMG_OFFSET} count=${OEM_IMG_SECTORS}
echo "Copying ESP..."
sudo dd if=${ESP_IMG} of=${FLAGS_dst} conv=notrunc bs=512 seek=${START_ESP} \
        skip=${ESP_IMG_OFFSET} count=${ESP_IMG_SECTORS}

# TODO: support arm during postinst so that we get partition selection and
#       verified boot.
if [ "$MACHINE_NAME" != "armv7l" ]; then

  # We can't guarantee that the kernel will see the new partition table, so
  # we can't use it directly. We could force the kernel to reload it with an
  # ioctl, but then we might have the UI mounting and displaying any old
  # filesystems left over from the last install, and we don't want that either.
  # So any access that we need to do to the destination partitions will have
  # to go through loop devices.

  # Now run the postinstall script in each new rootfs. Note that even though
  # we're passing the new destination partition number as an arg, the postinst
  # script had better not try to access it, for the reasons we just gave.
  loop_offset_setup ${FLAGS_dst} ${START_ROOTFS_A}
  trap loop_offset_cleanup EXIT
  mount_on_loop_dev
  trap my_cleanup EXIT
  sudo IS_INSTALL="1" ${TMPMNT}/postinst $(make_partition_dev ${FLAGS_dst} 3)
  umount_from_loop_dev
  trap loop_offset_cleanup EXIT
  loop_offset_cleanup
  trap - EXIT

  loop_offset_setup ${FLAGS_dst} ${START_ROOTFS_B}
  trap loop_offset_cleanup EXIT
  mount_on_loop_dev
  trap my_cleanup EXIT
  sudo IS_INSTALL="1" ${TMPMNT}/postinst $(make_partition_dev ${FLAGS_dst} 5)
  umount_from_loop_dev
  trap loop_offset_cleanup EXIT
  loop_offset_cleanup
  trap - EXIT
fi

echo "Installing the stateful partition..."
loop_offset_setup $FLAGS_dst $START_STATEFUL
trap loop_offset_cleanup EXIT
if [ "${FLAGS_preserve_stateful}" -eq "${FLAGS_FALSE}" ]; then
  sudo mkfs.ext3 -F -b 4096 -L "H-STATE" ${LOOP_DEV} \
    $(($NUM_STATEFUL_SECTORS / 8))
fi

#
# Install the stateful partition content
#
# In general, the system isn't allowed to depend on anything
# being in the stateful partition at startup.  We make some
# exceptions for dev images (only), as enumerated below:
#
# var/db/pkg
# var/lib/portage
#   These are included to support gmerge.
#
# dev_image
#   This provides tools specifically chosen to be mounted at
#   /usr/local as development only tools.
#
# Every exception added makes the dev image different from
# the release image, which could mask bugs.  Make sure every
# item you add here is well justified.
#
if [ -f /root/.dev_mode ]; then
  mount_on_loop_dev readwrite
  trap my_cleanup EXIT
  DIRLIST="
      var/db/pkg
      var/lib/portage
      dev_image
  "
  for DIR in ${DIRLIST}; do
    if [ ! -d /mnt/stateful_partition/${DIR} ]; then
      continue
    fi
    PARENT=$(dirname ${DIR})
    sudo mkdir -p ${TMPMNT}/${PARENT}
    sudo cp -fpru /mnt/stateful_partition/${DIR} ${TMPMNT}/${DIR}
  done
  umount_from_loop_dev
  trap loop_offset_cleanup EXIT
fi
loop_offset_cleanup
trap - EXIT

if grep "vogue" /etc/lsb-release > /dev/null; then
   sudo uboot-env.py -f /dev/mtdblock0 -o 0x7c000 -s 0x4000 \
    --set bootcmd="mmc read 0 C0008000 0 1; autoscr C0008000"
fi

# Force data to disk before we declare done.
sync

echo "------------------------------------------------------------"
echo ""
echo "Installation to '$FLAGS_dst' complete."
echo "Please shutdown, remove the USB device, cross your fingers, and reboot."
