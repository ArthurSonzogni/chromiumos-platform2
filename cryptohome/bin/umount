#!/bin/bash
# Copyright (c) 2009 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

set -e  # exit on error
set -E  # force error handler inheritance
set -u  # require all variables to be defined
trap error_handler ERR;

function error_handler() {
  cryptohome::log "unmount failed: the system may be rebooted"
  $sync || $true

  cryptohome::log "lsof ${DEFAULT_MOUNT_POINT}: $(lsof ${DEFAULT_MOUNT_POINT})"
  cryptohome::log "current mount table: $(mount)"

  cryptohome::is_mounted && $reboot
  cryptohome::log "unmount but the filesystem is no longer mounted"

  # Make sure we aren't leaving a mess or an accessible key.
  if cryptohome::is_opened; then
    cryptohome::log "device mapper device still present; attempting to close"
    cryptohome::log \
        "lsof ${DEFAULT_MAPPER_DEVICE}: $(lsof ${DEFAULT_MAPPER_DEVICE})"
    cryptohome::close || $reboot
    $exit 1
  fi

  if cryptohome::attached; then
    cryptohome::log "loop device still present; attempting to detach"
    cryptohome::detach || $reboot
    $exit 1
  fi

  cryptohome::log "forced unmount and cleanup successful"
  $exit 0
}

function umount_main() {
  # If we can't unmount, do it the hard way, for now.
  local target="${1:-$DEFAULT_MOUNT_POINT}"
  # Variables that define how long to wait for unmount to complete and the
  # increment to check for its completion.
  local max_delay=20
  local current_delay=0
  local increment=1

  # Loop until we've unmounted cryptohome or have reached the $max_delay.
  while cryptohome::is_mounted "$target" ; do
    if [ $current_delay -ge $max_delay ] ; then
      # If we've reached a max_delay, abort and go through reboot logic
      cryptohome::log "Unmount max delay reached.  Aborting."
      error_handler
    fi
    if ! cryptohome::unmount "$target" ; then
      cryptohome::log "Unmount error, sleeping and attempting to unmount again"
      $sync && $sleep $increment
      current_delay=$(( current_delay + increment ))
    fi
  done
  # is_mounted ignores incognito mounts since they diverge from
  # the actual cryptohome landscape (dm, losetup).
  if $mount | $grep -q "^$INCOGNITO_MOUNT_NAME "; then
    # We want all processes killed that use this mountpoint, but
    # we also need to ensure that the user is completely gone to
    # avoid processes persisting across mounts.
    cryptohome::log "unmounting incognito mount"
    $pkill -9 -u ${DEFAULT_USER} && $true &> /dev/null
    # Since we don't have additional work after the unmount, we can
    # do it lazily.
    $umount -n -l "$INCOGNITO_MOUNT_NAME"
  fi
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  source "$(dirname "$0")/../lib/chromeos-cryptohome/common"
  utils::declare_commands reboot exit sync
  umount_main "$@"
fi
