// Copyright 2023 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "cryptohome/recoverable_key_store/backend_cert_verify.h"

#include <memory>
#include <optional>
#include <string>
#include <string_view>
#include <type_traits>
#include <utility>
#include <vector>

#include <base/base64.h>
#include <base/strings/string_number_conversions.h>
#include <brillo/secure_blob.h>
#include <crypto/scoped_openssl_types.h>
#include <libhwsec-foundation/crypto/big_num_util.h>
#include <libhwsec-foundation/crypto/elliptic_curve.h>
#include <libhwsec-foundation/crypto/secure_box.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include <libxml/xpath.h>
#include <openssl/evp.h>
#include <openssl/safestack.h>
#include <openssl/x509.h>
#include <openssl/x509_vfy.h>

namespace cryptohome {

namespace {

using ::hwsec_foundation::EllipticCurve;
using ::hwsec_foundation::ScopedBN_CTX;

// These are not OpenSSL types, but the libchrome ScopedOpenSSL is generalized
// enough to be used with any type that we want to keep a pointer and free it
// with some existing free function when it goes out of scope. Use those
// wrappers instead of duplicating the utils.
using ScopedXmlDoc = ::crypto::ScopedOpenSSL<xmlDoc, xmlFreeDoc>;
using ScopedXmlXPathContext =
    ::crypto::ScopedOpenSSL<xmlXPathContext, xmlXPathFreeContext>;
using ScopedXmlXPathObject =
    ::crypto::ScopedOpenSSL<xmlXPathObject, xmlXPathFreeObject>;

using ScopedX509Store = ::crypto::ScopedOpenSSL<X509_STORE, X509_STORE_free>;
using ScopedX509StoreCtx =
    ::crypto::ScopedOpenSSL<X509_STORE_CTX, X509_STORE_CTX_free>;

// Destructor function of STACK_OF(TYPE) takes a second parameter to free actual
// objects in the stack, so we need a custom scoped type.
struct StackOfX509Free {
  void operator()(STACK_OF(X509) * ptr) const {
    sk_X509_pop_free(ptr, X509_free);
  }
};
using ScopedStackOfX509 = std::unique_ptr<STACK_OF(X509), StackOfX509Free>;
using ::crypto::ScopedX509;

constexpr xmlChar kSignatureXmlIntermediateCertsXPath[] =
    "/signature/intermediates/cert";
constexpr xmlChar kSignatureXmlSigningCertXPath[] = "/signature/certificate";
constexpr xmlChar kSignatureXmlSignatureXPath[] = "/signature/value";

constexpr xmlChar kCertXmlVersionXPath[] = "/certificate/metadata/serial";
constexpr xmlChar kCertXmlIntermediateCertsXPath[] =
    "/certificate/intermediates/cert";
constexpr xmlChar kCertXmlEndpointCertsXPath[] = "/certificate/endpoints/cert";

constexpr std::string_view kRecoverableKeyStoreServiceRootCaCommonName =
    "Google Cloud Key Vault Service Root CA";
// This is the root of trust for the backend certificate list verification. This
// is generated by the trusted execution platforms team
// (trusted-execution-platforms@google.com) and hardcoded in the server code
// that uses this cert in the google3 codebase. As a root CA cert, it should
// very rarely be changed. When changing this cert, please provide evidence of
// where the new certificate comes from, and contact the ChromeOS hwsec userland
// team (cros-hwsec-userland@google.com) to verify the new certificate with the
// trusted execution platforms team.
constexpr char kRecoverableKeyStoreServiceRootCaCert[] =
    "MIIFDzCCAvegAwIBAgIQbNdueU2o0vM9gGq4N6bhjzANBgkqhkiG9w0BAQsFADAx"
    "MS8wLQYDVQQDEyZHb29nbGUgQ2xvdWQgS2V5IFZhdWx0IFNlcnZpY2UgUm9vdCBD"
    "QTAeFw0xODA1MDcxODI0MDJaFw0zODA1MDgxOTI0MDJaMDExLzAtBgNVBAMTJkdv"
    "b2dsZSBDbG91ZCBLZXkgVmF1bHQgU2VydmljZSBSb290IENBMIICIjANBgkqhkiG"
    "9w0BAQEFAAOCAg8AMIICCgKCAgEArUgzu+4o9yl22eql1BiGBq3gWXooh2ql3J+v"
    "Vuzf/ThjzdIg0xkkkw/NAFxYFi49Eo1fa/hf8wCIoAqCEs1lD6tE3cCD3T3+EQPq"
    "uh6CB2KmZDJ6mPnXvVUlUuFr0O2MwZkwylqBETzK0x5NCHgL/p47vkjhHx6LqVao"
    "bigKlHxszvVi4fkt/qq7KW3YTVxhwdLGEab+OqSfwMxdBLhMfE0K0dvFt8bs8yJA"
    "F04DJsMbRChFFBpT17Z0u53iIAAu5qVQhKrQXiIAwgboZqd+JkHLXU1fJeVT5WJO"
    "JgoJFWHkdWkHta4mSYlS72J1Q927JD1JdET1kFtH+EDtYAtx7x7F9xAAbb2tMITw"
    "s/wwd2rAzZTX/kxRbDlXVLToU05LFYPr+dFV1wvXmi0jlkIxnhdaVBqWC93p528U"
    "iUcLpib+HVzMWGdYI3G1NOa/lTp0c8LcbJjapiiVneRQJ3cIqDPOSEnEq40hyZd1"
    "jx3JnOxJMwHs8v4s9GIlb3BcOmDvA/Mu09xEMKwpHBm4TFDKXeGHOWha7ccWEECb"
    "yO5ncu6XuN2iyz9S+TuMyjZBE552p6Pu5gEC2xk+qab0NGDTHdLKLbyWn3IxdmBH"
    "yTr7iPCqmpyHngkC/pbGfvGusc5BpBugsBtlz67m4RWLJ72yAeVPO/ly/8w4orNs"
    "GWjn3s0CAwEAAaMjMCEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8w"
    "DQYJKoZIhvcNAQELBQADggIBAGiWlu+4qyxgPb6RsA0mwR7V21UJ9rEpYhSN+ARp"
    "TWGiI22RCJSGK0ZrPGeFQzE2BpnVRdmLTV5jf9JUStjHoPvNYFnwLTJ0E2e9Olj8"
    "MrHrAucAUFLhl4woWz0kU/X0EB1j6Y2SXrAaZPiMMpq8BKj3mH1MbV4stZ0kiHUp"
    "Zu6PEmrojYG7FKKN30na2xXfiOfl2JusVsyHDqmUn/HjTh6zASKqE6hxE+FJRl2V"
    "Q4dcr4SviHtdbimMy2LghLnZ4FE4XhJgRnw9TeRV5C9Sn7pmnAA5X0C8ZXhXvfvr"
    "dx4fL3UKlk1Lqlb5skxoK1R9wwr+aNIO+cuR8JA5DmEDWFw5Budh/uWWZlBTyVW2"
    "ybbTB6tkmOc8c08XOgxBaKrsXALmJcluabjmN1jp81ae1epeN31jJ4N5IE5aq7Xb"
    "TFmKkwpgTTvJmqCR2XzWujlvdbdjfiABliWsnLzLQCP8eZwcM4LA5UK3f1ktHolr"
    "1OI9etSOkebE2py8LPYBJWlX36tRAagZhU/NoyOtvhRzq9rb3rbf96APEHKUFsXG"
    "9nBEd2BUKZghLKPf+JNCU/2pOGx0jdMcf+K+a1DeG0YzGYMRkFvpN3hvHYrJdByL"
    "3kSP3UtD0H2g8Ps7gRLELG2HODxbSn8PV3XtuSvxVanA6uyaaS3AZ6SxeVLvmw50"
    "7aYI";

std::string_view XmlCharArrayToString(const xmlChar* str) {
  // xmlChar* represents null-terminated UTF-8 string, so it can be casted
  // to char* safely.
  static_assert(std::is_same<xmlChar, unsigned char>());
  return std::string_view(reinterpret_cast<const char*>(str));
}

std::optional<brillo::Blob> Base64DecodeFromXmlCharArray(const xmlChar* str) {
  return base::Base64Decode(XmlCharArrayToString(str));
}

std::optional<std::vector<brillo::Blob>> ParseMultipleBase64Nodes(
    xmlXPathContextPtr ctx, const xmlChar* x_path) {
  std::vector<brillo::Blob> ret;
  ScopedXmlXPathObject obj(xmlXPathEvalExpression(x_path, ctx));
  if (!obj) {
    LOG(ERROR) << "Failed to create XPath object.";
    return std::nullopt;
  }

  xmlNodeSetPtr nodes = obj->nodesetval;
  if (!nodes || !nodes->nodeTab) {
    LOG(ERROR) << "XPath object's node set value is null.";
    return std::nullopt;
  }
  for (size_t i = 0; i < nodes->nodeNr; i++) {
    if (!nodes->nodeTab[i]) {
      LOG(DFATAL) << "Node tab within nodeNr index shouldn't be null.";
      return std::nullopt;
    }
    xmlNodePtr node = nodes->nodeTab[i]->children;
    if (!node || !node->content) {
      LOG(ERROR) << "Node has no content.";
      return std::nullopt;
    }
    std::optional<brillo::Blob> decoded =
        Base64DecodeFromXmlCharArray(node->content);
    if (!decoded.has_value()) {
      LOG(ERROR) << "Node content isn't valid Base64.";
      return std::nullopt;
    }
    ret.push_back(std::move(*decoded));
  }
  return ret;
}

const xmlChar* GetContentFromSinglePathObject(const xmlXPathObjectPtr obj) {
  xmlNodeSetPtr nodes = obj->nodesetval;
  if (!nodes || !nodes->nodeTab) {
    LOG(ERROR) << "XPath object's node set value is null.";
    return nullptr;
  }
  if (nodes->nodeNr != 1 || !nodes->nodeTab[0]) {
    LOG(ERROR) << "Number of nodes isn't exactly 1.";
    return nullptr;
  }
  xmlNodePtr node = nodes->nodeTab[0]->children;
  if (!node || !node->content) {
    LOG(ERROR) << "Node has no content.";
    return nullptr;
  }
  return node->content;
}

std::optional<brillo::Blob> ParseSingleBase64Node(xmlXPathContextPtr ctx,
                                                  const xmlChar* x_path) {
  ScopedXmlXPathObject obj(xmlXPathEvalExpression(x_path, ctx));
  if (!obj) {
    LOG(ERROR) << "Failed to create XPath object.";
    return std::nullopt;
  }

  const xmlChar* content = GetContentFromSinglePathObject(obj.get());
  if (!content) {
    return std::nullopt;
  }
  std::optional<brillo::Blob> decoded = Base64DecodeFromXmlCharArray(content);
  if (!decoded.has_value()) {
    LOG(ERROR) << "Node content isn't valid Base64.";
  }
  return decoded;
}

std::optional<uint64_t> ParseUint64Node(xmlXPathContextPtr ctx,
                                        const xmlChar* x_path) {
  ScopedXmlXPathObject obj(xmlXPathEvalExpression(x_path, ctx));
  if (!obj) {
    LOG(ERROR) << "Failed to create XPath object.";
    return std::nullopt;
  }

  const xmlChar* content = GetContentFromSinglePathObject(obj.get());
  if (!content) {
    return std::nullopt;
  }
  uint64_t ret;
  if (!base::StringToUint64(XmlCharArrayToString(content), &ret)) {
    LOG(ERROR) << "Node content isn't valid uint64_t";
    return std::nullopt;
  }
  return ret;
}

struct SignatureXmlParseResult {
  std::vector<brillo::Blob> intermediate_certs;
  brillo::Blob signing_cert;
  brillo::Blob signature;
};

// Check example xml format from
// https://www.gstatic.com/cryptauthvault/v0/cert.sig.xml.
std::optional<SignatureXmlParseResult> ParseSignatureXml(
    const std::string& signature_xml) {
  ScopedXmlDoc doc(xmlParseMemory(signature_xml.data(), signature_xml.size()));
  if (!doc) {
    LOG(ERROR) << "Failed to parse xml.";
    return std::nullopt;
  }

  ScopedXmlXPathContext xpath_ctx(xmlXPathNewContext(doc.get()));
  if (!xpath_ctx) {
    LOG(ERROR) << "Failed to create XPath context.";
    return std::nullopt;
  }

  // Parse the intermediate certs.
  std::optional<std::vector<brillo::Blob>> intermediate_certs =
      ParseMultipleBase64Nodes(xpath_ctx.get(),
                               kSignatureXmlIntermediateCertsXPath);
  if (!intermediate_certs.has_value()) {
    LOG(ERROR) << "Failed to parse the intermediate certs.";
    return std::nullopt;
  }

  // Parse the signing cert.
  std::optional<brillo::Blob> signing_cert =
      ParseSingleBase64Node(xpath_ctx.get(), kSignatureXmlSigningCertXPath);
  if (!signing_cert.has_value()) {
    LOG(ERROR) << "Failed to parse the signing cert.";
    return std::nullopt;
  }

  // Parse the signature.
  std::optional<brillo::Blob> signature =
      ParseSingleBase64Node(xpath_ctx.get(), kSignatureXmlSignatureXPath);
  if (!signature.has_value()) {
    LOG(ERROR) << "Failed to parse the signature.";
    return std::nullopt;
  }

  return SignatureXmlParseResult{
      .intermediate_certs = std::move(*intermediate_certs),
      .signing_cert = std::move(*signing_cert),
      .signature = std::move(*signature),
  };
}

ScopedX509 X509FromDer(const brillo::Blob& cert_der) {
  const uint8_t* cert_data = cert_der.data();
  return ScopedX509(d2i_X509(nullptr, &cert_data, cert_der.size()));
}

ScopedStackOfX509 ConstructIntermediateCertsStack(
    const std::vector<brillo::Blob>& certs) {
  ScopedStackOfX509 intermediate_certs(sk_X509_new_null());
  if (!intermediate_certs) {
    LOG(ERROR) << "Failed to allocate STACK_OF(X509) structure.";
    return nullptr;
  }
  for (const auto& cert : certs) {
    ScopedX509 x509 = X509FromDer(cert);
    if (!x509) {
      LOG(ERROR) << "Failed to parse intermediate cert as X509.";
      return nullptr;
    }

    X509_NAME* x509_name = X509_get_issuer_name(x509.get());
    if (!x509_name) {
      LOG(ERROR) << "Failed to get X509 issuer name.";
      return nullptr;
    }

    // X509_verify_cert requires each intermediate cert provided signed by a
    // trusted cert, even if the endpoint cert we want to verify doesn't need
    // that intermediate cert. So we can't just put all intermediate certs into
    // the X509 stack. We have to use the issuer name to determine whether the
    // cert is signed by our trusted CA cert.

    // Passing nullptr to buffer parameter returns the space needed (excluding
    // the terminating null).
    size_t issuer_name_length =
        X509_NAME_get_text_by_NID(x509_name, NID_commonName, nullptr, 0);
    if (issuer_name_length <= 0) {
      LOG(ERROR) << "Failed to get X509 issuer name text.";
      return nullptr;
    }
    if (issuer_name_length !=
        kRecoverableKeyStoreServiceRootCaCommonName.size()) {
      continue;
    }
    std::vector<char> issuer_name(issuer_name_length + 1);
    if (X509_NAME_get_text_by_NID(x509_name, NID_commonName, issuer_name.data(),
                                  issuer_name.size()) != issuer_name_length) {
      LOG(ERROR) << "X509 issuer name length mismatched.";
      return nullptr;
    }
    if (std::string_view(issuer_name.data()) !=
        kRecoverableKeyStoreServiceRootCaCommonName) {
      continue;
    }
    // STACK_OF(X509) references but doesn't own its entries, so the x509
    // objects need to outlive the stack. Releasing the ownership is fine
    // because we use sk_X509_pop_free on stack destruction that will free the
    // entries explicitly.
    if (sk_X509_push(intermediate_certs.get(), std::move(x509).release()) < 0) {
      LOG(ERROR) << "Failed to push X509 cert into STACK_OF(X509).";
      return nullptr;
    }
  }
  return intermediate_certs;
}

ScopedX509Store ConstructTrustedCertStore() {
  ScopedX509Store trusted_cert_store(X509_STORE_new());
  if (!trusted_cert_store) {
    LOG(ERROR) << "Failed to allocate X509_STORE structure.";
    return nullptr;
  }
  std::optional<brillo::Blob> trusted_cert =
      base::Base64Decode(kRecoverableKeyStoreServiceRootCaCert);
  if (!trusted_cert.has_value()) {
    LOG(ERROR) << "Failed to Base64Decode recoverable key service CA cert.";
    return nullptr;
  }
  ScopedX509 x509 = X509FromDer(*trusted_cert);
  if (!x509) {
    LOG(ERROR) << "Failed to parse CA cert as X509.";
    return nullptr;
  }
  if (X509_STORE_add_cert(trusted_cert_store.get(), x509.get()) != 1) {
    LOG(ERROR) << "Failed to add CA cert to X509 store.";
    return nullptr;
  }
  return trusted_cert_store;
}

// |ConstructTrustedCertStore| should always return the same result, so cache
// the generated cert store. Note that we don't retry on the next call even if
// the initial construction has failed.
X509_STORE* GetTrustedCertStore() {
  static X509_STORE* trusted_store = ConstructTrustedCertStore().release();
  return trusted_store;
}

// |intermediate_certs|, |trusted_cert_store|, and |endpoint_cert| can't be
// const because X509_STORE_CTX_init takes mutable pointers, but in fact the
// data pointed by them will never be modified by X509_STORE_CTX methods, nor
// will be cleaned up / freed by X509_STORE_CTX. Callers can safely assume that
// those params will not be mutated.
bool VerifyEndpointCert(X509_STORE_CTX* ctx,
                        STACK_OF(X509) * intermediate_certs,
                        X509_STORE* trusted_cert_store,
                        X509* endpoint_cert) {
  if (X509_STORE_CTX_init(ctx, trusted_cert_store, endpoint_cert,
                          intermediate_certs) != 1) {
    LOG(ERROR) << "Failed to init X509 store context.";
    return false;
  }
  return X509_verify_cert(ctx) == 1;
}

// Returns the signing cert x509 after verifying.
crypto::ScopedX509 VerifySignatureXmlCertificateChain(
    const SignatureXmlParseResult& signature) {
  // 1. Prepare the intermediate certs into STACK_OF(X509) structure.
  ScopedStackOfX509 intermediate_certs =
      ConstructIntermediateCertsStack(signature.intermediate_certs);
  if (!intermediate_certs) {
    LOG(ERROR) << "Failed to construct intermediate certs X509 stack.";
    return nullptr;
  }

  // 2. Prepare the trusted cert into X509_STORE structure.
  X509_STORE* trusted_cert_store = GetTrustedCertStore();
  if (!trusted_cert_store) {
    LOG(ERROR) << "Failed to construct the trusted cert store.";
    return nullptr;
  }

  // 3. Verify the endpoint cert.
  ScopedX509StoreCtx verify_ctx(X509_STORE_CTX_new());
  if (!verify_ctx) {
    LOG(ERROR) << "Failed to allocate X509_STORE_CTX structure.";
    return nullptr;
  }
  crypto::ScopedX509 signing_cert = X509FromDer(signature.signing_cert);
  if (!signing_cert) {
    LOG(ERROR) << "Failed to parse signing cert as X509.";
    return nullptr;
  }
  if (!VerifyEndpointCert(verify_ctx.get(), intermediate_certs.get(),
                          trusted_cert_store, signing_cert.get())) {
    LOG(ERROR) << "Failed to verify the signing certificate.";
    return nullptr;
  }
  return signing_cert;
}

bool VerifyCertificateXmlSignature(const std::string& cert_xml,
                                   const brillo::Blob& signature,
                                   X509* signing_cert) {
  crypto::ScopedEVP_PKEY public_key(X509_get_pubkey(signing_cert));
  if (!public_key) {
    LOG(ERROR) << "Failed to extract public key from certificate.";
    return false;
  }

  crypto::ScopedEVP_MD_CTX ctx(EVP_MD_CTX_new());
  if (!ctx) {
    LOG(ERROR) << "Failed to allocate EVP_MD_CTX structure.";
    return false;
  }

  if (!EVP_DigestVerifyInit(ctx.get(), nullptr, EVP_sha256(), nullptr,
                            public_key.get())) {
    LOG(ERROR) << "Failed to initialize digest verify context.";
    return false;
  }

  return EVP_DigestVerify(
      ctx.get(), signature.data(), signature.size(),
      reinterpret_cast<const unsigned char*>(cert_xml.data()), cert_xml.size());
}

struct CertificateXmlParseResult {
  uint64_t version;
  std::vector<brillo::Blob> intermediate_certs;
  std::vector<brillo::Blob> endpoint_certs;
};

// Check example xml format from
// https://www.gstatic.com/cryptauthvault/v0/cert.xml.
std::optional<CertificateXmlParseResult> ParseCertificateXml(
    const std::string& cert_xml) {
  ScopedXmlDoc doc(xmlParseMemory(cert_xml.data(), cert_xml.size()));
  if (!doc) {
    LOG(ERROR) << "Failed to parse xml.";
    return std::nullopt;
  }

  ScopedXmlXPathContext xpath_ctx(xmlXPathNewContext(doc.get()));
  if (!xpath_ctx) {
    LOG(ERROR) << "Failed to create XPath context.";
    return std::nullopt;
  }

  std::optional<uint64_t> version =
      ParseUint64Node(xpath_ctx.get(), kCertXmlVersionXPath);
  if (!version.has_value()) {
    LOG(ERROR) << "Failed to parse version field.";
    return std::nullopt;
  }

  // Parse the intermediate certs.
  std::optional<std::vector<brillo::Blob>> intermediate_certs =
      ParseMultipleBase64Nodes(xpath_ctx.get(), kCertXmlIntermediateCertsXPath);
  if (!intermediate_certs.has_value()) {
    LOG(ERROR) << "Failed to parse the intermediate certs.";
    return std::nullopt;
  }

  // Parse the endpoint certs.
  std::optional<std::vector<brillo::Blob>> endpoint_certs =
      ParseMultipleBase64Nodes(xpath_ctx.get(), kCertXmlEndpointCertsXPath);
  if (!endpoint_certs.has_value()) {
    LOG(ERROR) << "Failed to parse the endpoint certs.";
    return std::nullopt;
  }

  return CertificateXmlParseResult{
      .version = *version,
      .intermediate_certs = std::move(*intermediate_certs),
      .endpoint_certs = std::move(*endpoint_certs),
  };
}

// Returns the endpoint cert x509s after verifying.
std::vector<crypto::ScopedX509> VerifyCertificateXmlCertificateChain(
    const CertificateXmlParseResult& certificate) {
  // 1. Prepare the intermediate certs into STACK_OF(X509) structure.
  ScopedStackOfX509 intermediate_certs =
      ConstructIntermediateCertsStack(certificate.intermediate_certs);
  if (!intermediate_certs) {
    LOG(ERROR) << "Failed to construct intermediate certs X509 stack.";
    return {};
  }

  // 2. Prepare the trusted cert into X509_STORE structure.
  X509_STORE* trusted_cert_store = GetTrustedCertStore();
  if (!trusted_cert_store) {
    LOG(ERROR) << "Failed to construct the trusted cert store.";
    return {};
  }

  // 3. Verify the endpoint cert.
  ScopedX509StoreCtx verify_ctx(X509_STORE_CTX_new());
  if (!verify_ctx) {
    LOG(ERROR) << "Failed to allocate X509_STORE_CTX structure.";
    return {};
  }
  std::vector<crypto::ScopedX509> ret;
  for (const auto& cert : certificate.endpoint_certs) {
    ScopedX509 endpoint_cert = X509FromDer(cert);
    if (!endpoint_cert) {
      LOG(ERROR) << "Failed to parse endpoint_cert cert as X509.";
      return {};
    }
    if (!VerifyEndpointCert(verify_ctx.get(), intermediate_certs.get(),
                            trusted_cert_store, endpoint_cert.get())) {
      LOG(ERROR) << "Failed to verify the endpoint certificate.";
      return {};
    }
    ret.push_back(std::move(endpoint_cert));
  }
  return ret;
}

std::vector<RecoverableKeyStoreCert> EncodeEndpointCertificates(
    const std::vector<crypto::ScopedX509>& certs) {
  std::vector<RecoverableKeyStoreCert> ret;

  ScopedBN_CTX context = hwsec_foundation::CreateBigNumContext();
  if (!context) {
    LOG(ERROR) << "Failed to allocate BIGNUM context.";
    return {};
  }
  std::optional<EllipticCurve> curve =
      EllipticCurve::Create(EllipticCurve::CurveType::kPrime256, context.get());
  if (!curve.has_value()) {
    LOG(ERROR) << "Failed to create EllipticCurve.";
    return {};
  }

  for (const auto& cert : certs) {
    const EVP_PKEY* public_key = X509_get0_pubkey(cert.get());
    if (!public_key) {
      LOG(ERROR) << "Failed to extract public key from certificate.";
      return {};
    }
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(public_key);
    if (!ec_key) {
      LOG(ERROR) << "Public key from certificate is not EC key.";
      return {};
    }
    const EC_POINT* ec_point = EC_KEY_get0_public_key(ec_key);
    if (!ec_point) {
      LOG(ERROR) << "Failed to get public key point from EC key.";
      return {};
    }
    std::optional<brillo::Blob> encoded =
        hwsec_foundation::secure_box::EncodePublicKey(*curve, context.get(),
                                                      *ec_point);
    if (!encoded.has_value()) {
      return {};
    }
    ret.push_back(RecoverableKeyStoreCert{
        .public_key = std::move(*encoded),
    });
  }
  return ret;
}

}  // namespace

// TODO(b/315094662): Add fuzzer for parsing of untrusted data.

std::optional<uint64_t> GetCertXmlVersion(const std::string& cert_xml) {
  std::optional<CertificateXmlParseResult> cert_result =
      ParseCertificateXml(cert_xml);
  if (!cert_result.has_value()) {
    LOG(ERROR) << "Failed to parse certificate xml.";
    return std::nullopt;
  }
  return cert_result->version;
}

std::optional<RecoverableKeyStoreCertList>
VerifyAndParseRecoverableKeyStoreBackendCertXmls(
    const std::string& cert_xml, const std::string& signature_xml) {
  // TODO(b/309734008): Record metrics of the verification and parsing result.
  // 1. Parse the signature XML.
  std::optional<SignatureXmlParseResult> signature_result =
      ParseSignatureXml(signature_xml);
  if (!signature_result.has_value()) {
    LOG(ERROR) << "Failed to parse signature xml.";
    return std::nullopt;
  }
  // 2. Verify the signature XML's certificates.
  crypto::ScopedX509 signing_cert =
      VerifySignatureXmlCertificateChain(*signature_result);
  if (!signing_cert) {
    LOG(ERROR) << "Failed to verify signature xml's certificate chain.";
    return std::nullopt;
  }
  // 3. Verify the certificate XML's integrity using the signature.
  if (!VerifyCertificateXmlSignature(cert_xml, signature_result->signature,
                                     signing_cert.get())) {
    LOG(ERROR) << "Failed to verify certificate xml's signature.";
    return std::nullopt;
  }
  // 4. Parse the certificate XML.
  std::optional<CertificateXmlParseResult> cert_result =
      ParseCertificateXml(cert_xml);
  if (!cert_result.has_value()) {
    LOG(ERROR) << "Failed to parse certificate xml.";
    return std::nullopt;
  }
  // 5. Verify the certificate XML's certificates.
  std::vector<crypto::ScopedX509> endpoint_certs =
      VerifyCertificateXmlCertificateChain(*cert_result);
  if (endpoint_certs.empty()) {
    LOG(ERROR) << "Failed to verify certificate xml's certificate chain.";
    return std::nullopt;
  }
  // 6. Encode the endpoint certificates.
  std::vector<RecoverableKeyStoreCert> key_store_certs =
      EncodeEndpointCertificates(endpoint_certs);
  if (key_store_certs.empty()) {
    LOG(ERROR) << "Failed to encode endpoint certificates.";
    return std::nullopt;
  }
  return RecoverableKeyStoreCertList{
      .version = cert_result->version,
      .certs = std::move(key_store_certs),
  };
}

}  // namespace cryptohome
