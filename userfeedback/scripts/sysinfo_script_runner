#!/bin/sh

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.
#
# This script executes each line in a flat file of commands.
# The first parameter to this script needs to be either 'feedback' or
# 'sysinfo'; this indicates the context the script was called in. This value
# will be set in the environment variable SYSLOG_CONTEXT which can be picked
# up by the scripts that are run from the list file. The list files need to
# have the extension .lst
#
#
# Goes through a file line by line ignoring '#' style comments
# and whitespace.
#
# Each line will be executed and the output will setup such that
# our feedback mechanism will pick it up correctly.
#
# The file format is key/value pairs delimited by a comma. The value will
# be executed. We will use the command that is executed as the key if it is
# not provided.
#
# Example -> cpuinfo,cat /proc/cpuinfo
# In this case the output of cat /proc/cpuinfo will be logged as "cpuinfo"
#
# Arguments:
#  $1 - Context this script was called in (defaults to 'sysinfo')
#       This context is put in an environment variable called SYSLOG_CONTEXT
#       and can be examined by any script
#  $2 - The directory to pick up the scripts from (defaults to ../etc)
#
simple_line_executor() {
  # Do not exit in case a script wasn't found or threw an error.
  while i=`line`
  do
    if [ ${#i} -eq 0 ]; then
      continue
    fi

   if expr "${i}" : '[ \t]*#' >/dev/null; then
     continue
   fi

    # Split the line into a key and value.
    local key="$(echo ${i} | awk -F, '{ print $1 }')"
    local value="$(echo ${i} | awk -F, '{ print $2 }')"
    if [ ${#value} -eq 0 ]; then
      value=${i}
    fi
    local format="$(echo ${i} | awk -F, '{ print $3 }')"

    echo "${key}"='"""'
    if [ "${format}" = "ascii" ]; then
      # Replace non printable ascii characters (^\n,\r,\t,' '-'~') with "~"
      # and make sure we don't mess up our quoting.
      eval "${value}" 2> /dev/null | tr -c '\n\r\t\40-\176' '~' | \
        sed -e "s/\"\"\"/'''/g"
    else
      eval "${value}" 2> /dev/null | sed -e "s/\"\"\"/'''/g"
    fi
    echo '"""'

  done < ${1}
}

SYSLOG_CONTEXT=${1}
if [ "${CONTEXT}" != "feedback" ] && [ "${CONTEXT}" != "sysinfo" ]; then
  SYSLOG_CONTEXT="sysinfo"
fi
export SYSLOG_CONTEXT

if [ -f "${2}" ]; then
  SCRIPTS_DIR=${2}
else
  SCRIPTS_DIR="$(dirname "$0")/../etc"
fi

# Dump the key-val pairs from lsb-release.
cat /etc/lsb-release

# Run the listing scripts
for file in $(ls ${SCRIPTS_DIR}/*.lst)
do
  simple_line_executor ${file}
done

