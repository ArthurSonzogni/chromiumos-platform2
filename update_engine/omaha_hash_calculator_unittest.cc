// Copyright (c) 2009 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <math.h>
#include <unistd.h>
#include <glib.h>
#include <gtest/gtest.h>
#include "update_engine/libcurl_http_fetcher.h"
#include "update_engine/omaha_hash_calculator.h"

namespace chromeos_update_engine {

class OmahaHashCalculatorTest : public ::testing::Test { };

TEST(OmahaHashCalculatorTest, SimpleTest) {
  OmahaHashCalculator calc;
  calc.Update("hi", 2);
  calc.Finalize();
  // Generated by running this on a linux shell:
  // $ echo -n hi | openssl sha1 -binary | openssl base64
  EXPECT_EQ("witfkXg0JglCjW9RssWvTAveakI=", calc.hash());
}

TEST(OmahaHashCalculatorTest, MultiUpdateTest) {
  OmahaHashCalculator calc;
  calc.Update("h", 1);
  calc.Update("i", 1);
  calc.Finalize();
  // Generated by running this on a linux shell:
  // $ echo -n hi | openssl sha1 -binary | openssl base64
  EXPECT_EQ("witfkXg0JglCjW9RssWvTAveakI=", calc.hash());
}

TEST(OmahaHashCalculatorTest, BigTest) {
  OmahaHashCalculator calc;

  for (int i = 0; i < 1000000; i++) {
    char buf[8];
    ASSERT_EQ(0 == i ? 1 : static_cast<int>(floorf(logf(i) / logf(10))) + 1,
              snprintf(buf, sizeof(buf), "%d", i)) << " i = " << i;
    calc.Update(buf, strlen(buf));
  }
  calc.Finalize();

  // Hash constant generated by running this on a linux shell:
  // $ C=0
  // $ while [ $C -lt 1000000 ]; do
  //     echo -n $C
  //     let C=C+1
  //   done | openssl sha1 -binary | openssl base64
  EXPECT_EQ("qdNsMeRqzoEUu5/ABi+MGRli87s=", calc.hash());
}

TEST(OmahaHashCalculatorTest, AbortTest) {
  // Just make sure we don't crash and valgrind doesn't detect memory leaks
  {
    OmahaHashCalculator calc;
  }
  {
    OmahaHashCalculator calc;
    calc.Update("h", 1);
  }
}

}  // namespace chromeos_update_engine
