// Copyright 2019 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "patchpanel/ndproxy.h"

#include <stdlib.h>

#include <net/ethernet.h>

#include <memory>
#include <string>
#include <utility>
#include <vector>

#include <base/logging.h>
#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include "patchpanel/net_util.h"

using testing::_;

namespace patchpanel {

const MacAddress physical_if_mac({0xa0, 0xce, 0xc8, 0xc6, 0x91, 0x0a});
const MacAddress guest_if_mac({0xd2, 0x47, 0xf7, 0xc5, 0x9e, 0x53});

const uint8_t ping_frame[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x86, 0xdd, 0x60, 0x0b, 0x8d, 0xb4, 0x00, 0x40, 0x3a, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0xb9, 0x3c, 0x13, 0x8f,
    0x00, 0x09, 0xde, 0x6a, 0x78, 0x5d, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x13,
    0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
    0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37};

const uint8_t rs_frame[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x02, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0,
    0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x10, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75, 0xb2, 0x80, 0x97, 0x83,
    0x76, 0xbf, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x85, 0x00, 0x2f, 0xfc, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0};

// The byte at index 19 should be 0x10 instead of 0x11
const uint8_t rs_frame_too_large_plen[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x02, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0,
    0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x11, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75, 0xb2, 0x80, 0x97, 0x83,
    0x76, 0xbf, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x85, 0x00, 0x2f, 0xfc, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0};

// The byte at index 19 should be 0x10 instead of 0x0f
const uint8_t rs_frame_too_small_plen[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x02, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0,
    0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75, 0xb2, 0x80, 0x97, 0x83,
    0x76, 0xbf, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x85, 0x00, 0x2f, 0xfc, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0};

const uint8_t rs_frame_translated[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x02, 0xa0, 0xce, 0xc8, 0xc6, 0x91, 0x0a,
    0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x10, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75, 0xb2, 0x80, 0x97, 0x83,
    0x76, 0xbf, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x85, 0x00, 0x93, 0x55, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0xa0, 0xce, 0xc8, 0xc6, 0x91, 0x0a};

const uint8_t ra_frame[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x01, 0xc4, 0x71, 0xfe, 0xf1, 0xf6, 0x7f,
    0x86, 0xdd, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1,
    0xf6, 0x7f, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0x00, 0x8a, 0xd5, 0x40, 0x00,
    0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
    0xc4, 0x71, 0xfe, 0xf1, 0xf6, 0x7f, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x05, 0xdc, 0x03, 0x04, 0x40, 0xc0, 0x00, 0x27, 0x8d, 0x00, 0x00, 0x09,
    0x3a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0xfa, 0x00, 0x00, 0x04,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t ra_frame_translated[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x01, 0xd2, 0x47, 0xf7, 0xc5, 0x9e, 0x53,
    0x86, 0xdd, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1,
    0xf6, 0x7f, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0x00, 0xdc, 0x53, 0x40, 0x04,
    0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
    0xd2, 0x47, 0xf7, 0xc5, 0x9e, 0x53, 0x05, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x05, 0xdc, 0x03, 0x04, 0x40, 0xc0, 0x00, 0x27, 0x8d, 0x00, 0x00, 0x09,
    0x3a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0xfa, 0x00, 0x00, 0x04,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t ra_frame_option_reordered[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x01, 0xc4, 0x71, 0xfe, 0xf1, 0xf6, 0x7f,
    0x86, 0xdd, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1,
    0xf6, 0x7f, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0x00, 0x8a, 0xd5, 0x40, 0x00,
    0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x05, 0xdc, 0x01, 0x01, 0xc4, 0x71, 0xfe, 0xf1,
    0xf6, 0x7f, 0x03, 0x04, 0x40, 0xc0, 0x00, 0x27, 0x8d, 0x00, 0x00, 0x09,
    0x3a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0xfa, 0x00, 0x00, 0x04,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t ra_frame_option_reordered_translated[] = {
    0x33, 0x33, 0x00, 0x00, 0x00, 0x01, 0xd2, 0x47, 0xf7, 0xc5, 0x9e, 0x53,
    0x86, 0xdd, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x40, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1,
    0xf6, 0x7f, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x86, 0x00, 0xdc, 0x53, 0x40, 0x04,
    0x07, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x05, 0xdc, 0x01, 0x01, 0xd2, 0x47, 0xf7, 0xc5,
    0x9e, 0x53, 0x03, 0x04, 0x40, 0xc0, 0x00, 0x27, 0x8d, 0x00, 0x00, 0x09,
    0x3a, 0x80, 0x00, 0x00, 0x00, 0x00, 0x24, 0x01, 0xfa, 0x00, 0x00, 0x04,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const uint8_t ns_frame[] = {
    0xd2, 0x47, 0xf7, 0xc5, 0x9e, 0x53, 0x1a, 0x9b, 0x82, 0xbd, 0xc0,
    0xa0, 0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3a, 0xff,
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75, 0xb2,
    0x80, 0x97, 0x83, 0x76, 0xbf, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1, 0xf6, 0x7f, 0x87,
    0x00, 0xba, 0x27, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1, 0xf6,
    0x7f, 0x01, 0x01, 0x1a, 0x9b, 0x82, 0xbd, 0xc0, 0xa0};

const uint8_t ns_frame_translated[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xce, 0xc8, 0xc6, 0x91,
    0x0a, 0x86, 0xdd, 0x60, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3a, 0xff,
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75, 0xb2,
    0x80, 0x97, 0x83, 0x76, 0xbf, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1, 0xf6, 0x7f, 0x87,
    0x00, 0x1d, 0x81, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1, 0xf6,
    0x7f, 0x01, 0x01, 0xa0, 0xce, 0xc8, 0xc6, 0x91, 0x0a};

const uint8_t na_frame[] = {
    0xa0, 0xce, 0xc8, 0xc6, 0x91, 0x0a, 0xc4, 0x71, 0xfe, 0xf1, 0xf6, 0x7f,
    0x86, 0xdd, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1,
    0xf6, 0x7f, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75,
    0xb2, 0x80, 0x97, 0x83, 0x76, 0xbf, 0x88, 0x00, 0x58, 0x29, 0xc0, 0x00,
    0x00, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71,
    0xfe, 0xff, 0xfe, 0xf1, 0xf6, 0x7f};

const uint8_t na_frame_translated[] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd2, 0x47, 0xf7, 0xc5, 0x9e, 0x53,
    0x86, 0xdd, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3a, 0xff, 0xfe, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71, 0xfe, 0xff, 0xfe, 0xf1,
    0xf6, 0x7f, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x75,
    0xb2, 0x80, 0x97, 0x83, 0x76, 0xbf, 0x88, 0x00, 0x58, 0x29, 0xc0, 0x00,
    0x00, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x71,
    0xfe, 0xff, 0xfe, 0xf1, 0xf6, 0x7f};

const uint8_t tcp_frame[] = {
    0xc4, 0x71, 0xfe, 0xf1, 0xf6, 0x7f, 0xa0, 0xce, 0xc8, 0xc6, 0x91,
    0x0a, 0x86, 0xdd, 0x60, 0x03, 0xa3, 0x57, 0x00, 0x20, 0x06, 0x40,
    0x24, 0x01, 0xfa, 0x00, 0x00, 0x04, 0x00, 0x02, 0xf0, 0x94, 0x0d,
    0xa1, 0x12, 0x6f, 0xfd, 0x6b, 0x24, 0x04, 0x68, 0x00, 0x40, 0x08,
    0x0c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x85,
    0xc0, 0x01, 0xbb, 0xb2, 0x7e, 0xd0, 0xa6, 0x0c, 0x57, 0xa5, 0x6c,
    0x80, 0x10, 0x01, 0x54, 0x04, 0xb9, 0x00, 0x00, 0x01, 0x01, 0x08,
    0x0a, 0x00, 0x5a, 0x59, 0xc0, 0x32, 0x53, 0x14, 0x3a};

const uint8_t global_na_packet[] = {
    0x60, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3a, 0xff, 0x2a, 0x00, 0x79, 0xe1,
    0x0a, 0xbc, 0xf6, 0x05, 0x94, 0x06, 0xd4, 0xff, 0xfe, 0x06, 0x12, 0x58,
    0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0xfa, 0xe8, 0xff,
    0xfe, 0x54, 0x07, 0x49, 0x88, 0x00, 0x56, 0x3e, 0x60, 0x00, 0x00, 0x00,
    0x2a, 0x00, 0x79, 0xe1, 0x0a, 0xbc, 0xf6, 0x05, 0x94, 0x06, 0xd4, 0xff,
    0xfe, 0x06, 0x12, 0x58, 0x02, 0x01, 0x34, 0x13, 0xe8, 0xb4, 0x24, 0x72};

const uint8_t global_ns_packet[] = {
    0x60, 0x00, 0x00, 0x00, 0x00, 0x20, 0x3a, 0xff, 0x2a, 0x00, 0x79, 0xe1,
    0x0a, 0xbc, 0xf6, 0x05, 0x5c, 0x5e, 0xa5, 0xff, 0xfe, 0x32, 0x74, 0x3c,
    0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0xff, 0x06, 0x12, 0x58, 0x87, 0x00, 0xee, 0x8c, 0x00, 0x00, 0x00, 0x00,
    0x2a, 0x00, 0x79, 0xe1, 0x0a, 0xbc, 0xf6, 0x05, 0x94, 0x06, 0xd4, 0xff,
    0xfe, 0x06, 0x12, 0x58, 0x01, 0x01, 0x34, 0x13, 0xe8, 0xb4, 0x24, 0x72};

constexpr const char hex_chars[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                      '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

std::string ToHexString(const uint8_t* buffer, size_t len) {
  std::string s;
  std::string sep;
  for (int i = 0; i < len; i++) {
    const uint8_t b = buffer[i];
    s += sep;
    s += "0x";
    s += hex_chars[(b & 0xF0) >> 4];
    s += hex_chars[(b & 0x0F) >> 0];
    sep = ", ";
  }
  return s;
}

TEST(NDProxyTest, GetPrefixInfoOption) {
  uint8_t in_buffer[IP_MAXPACKET];

  struct {
    std::string name;
    const uint8_t* input_frame;
    size_t input_frame_len;
    uint8_t expected_prefix_len;
    uint32_t expected_valid_time;
    uint32_t expected_preferred_time;
  } test_cases[] = {
      {
          "ra_frame",
          ra_frame,
          sizeof(ra_frame),
          64,
          ntohl(720 * 60 * 60),
          ntohl(168 * 60 * 60),
      },
      {
          "ra_frame_translated",
          ra_frame_translated,
          sizeof(ra_frame_translated),
          64,
          ntohl(720 * 60 * 60),
          ntohl(168 * 60 * 60),
      },
      {
          "ra_frame_option_reordered",
          ra_frame_option_reordered,
          sizeof(ra_frame_option_reordered),
          64,
          ntohl(720 * 60 * 60),
          ntohl(168 * 60 * 60),
      },
      {
          "ra_frame_option_reordered_translated",
          ra_frame_option_reordered_translated,
          sizeof(ra_frame_option_reordered_translated),
          64,
          ntohl(720 * 60 * 60),
          ntohl(168 * 60 * 60),
      },
      {
          "rs_frame",
          rs_frame,
          sizeof(rs_frame),
          0,
          0,
          0,
      },
      {
          "ns_frame",
          ns_frame,
          sizeof(ns_frame),
          0,
          0,
          0,
      },
      {
          "na_frame",
          na_frame,
          sizeof(na_frame),
          0,
          0,
          0,
      },
  };

  for (const auto& test_case : test_cases) {
    LOG(INFO) << test_case.name;

    size_t packet_len = test_case.input_frame_len - ETHER_HDR_LEN;
    memcpy(in_buffer, test_case.input_frame + ETHER_HDR_LEN, packet_len);

    size_t offset = sizeof(ip6_hdr);
    size_t icmp6_len = packet_len - offset;
    const nd_opt_prefix_info* prefix_info =
        NDProxy::GetPrefixInfoOption(in_buffer + offset, icmp6_len);

    if (test_case.expected_prefix_len == 0) {
      EXPECT_EQ(nullptr, prefix_info);
    } else {
      EXPECT_NE(nullptr, prefix_info);
      EXPECT_EQ(test_case.expected_prefix_len,
                prefix_info->nd_opt_pi_prefix_len);
      EXPECT_EQ(test_case.expected_valid_time,
                prefix_info->nd_opt_pi_valid_time);
      EXPECT_EQ(test_case.expected_preferred_time,
                prefix_info->nd_opt_pi_preferred_time);
    }
  }
}

// NDProxy with functions interacting with kernel state faked
class NDProxyUnderTest : public NDProxy {
 public:
  void RegisterNeighbor(const net_base::IPv6Address& ipv6_addr,
                        const MacAddress& mac_addr) {
    neighbor_table_.emplace_back(ipv6_addr, mac_addr);
  }

 private:
  std::vector<std::pair<net_base::IPv6Address, MacAddress>> neighbor_table_;

  bool GetLocalMac(int if_id, MacAddress* mac_addr) override { return false; }

  bool GetNeighborMac(const net_base::IPv6Address& ipv6_addr,
                      MacAddress* mac_addr) override {
    for (const auto& neighbor : neighbor_table_) {
      if (ipv6_addr == neighbor.first) {
        memcpy(mac_addr, &neighbor.second, ETHER_ADDR_LEN);
        return true;
      }
    }
    return false;
  }

  std::optional<net_base::IPv6Address> GetLinkLocalAddress(int if_id) override {
    return std::nullopt;
  }

  FRIEND_TEST(NDProxyTest, ResolveDestinationMac);
  FRIEND_TEST(NDProxyTest, TranslateFrame);
  FRIEND_TEST(NDProxyTest, GuestDiscoveryCallback);
  FRIEND_TEST(NDProxyTest, RouterDiscoveryCallback);
};

TEST(NDProxyTest, TranslateFrame) {
  uint8_t* in_buffer = new uint8_t[IP_MAXPACKET];
  uint8_t* out_buffer = new uint8_t[IP_MAXPACKET];
  ssize_t result;

  struct {
    std::string name;
    const uint8_t* input_frame;
    size_t input_frame_len;
    MacAddress local_mac;
    std::optional<net_base::IPv6Address> src_ip;
    std::optional<net_base::IPv6Address> dst_ip;
    ssize_t expected_error;
    const uint8_t* expected_output_frame;
    size_t expected_output_frame_len;
  } test_cases[] = {
      {
          "tcp_frame",
          tcp_frame,
          sizeof(tcp_frame),
          physical_if_mac,
          std::nullopt,
          std::nullopt,
          NDProxy::kTranslateErrorNotICMPv6Packet,
      },
      {
          "ping_frame",
          ping_frame,
          sizeof(ping_frame),
          physical_if_mac,
          std::nullopt,
          std::nullopt,
          NDProxy::kTranslateErrorNotNDPacket,
      },
      {
          "rs_frame_too_large_plen",
          rs_frame_too_large_plen,
          sizeof(rs_frame_too_large_plen),
          physical_if_mac,
          std::nullopt,
          std::nullopt,
          NDProxy::kTranslateErrorMismatchedIp6Length,
      },
      {
          "rs_frame_too_small_plen",
          rs_frame_too_small_plen,
          sizeof(rs_frame_too_small_plen),
          physical_if_mac,
          std::nullopt,
          std::nullopt,
          NDProxy::kTranslateErrorMismatchedIp6Length,
      },
      {
          "rs_frame",
          rs_frame,
          sizeof(rs_frame),
          physical_if_mac,
          std::nullopt,
          std::nullopt,
          0,  // no error
          rs_frame_translated,
          sizeof(rs_frame_translated),
      },
      {
          "ra_frame",
          ra_frame,
          sizeof(ra_frame),
          guest_if_mac,
          std::nullopt,
          std::nullopt,
          0,  // no error
          ra_frame_translated,
          sizeof(ra_frame_translated),
      },
      {
          "ra_frame_option_reordered",
          ra_frame_option_reordered,
          sizeof(ra_frame_option_reordered),
          guest_if_mac,
          std::nullopt,
          std::nullopt,
          0,  // no error
          ra_frame_option_reordered_translated,
          sizeof(ra_frame_option_reordered_translated),
      },
      {
          "ns_frame",
          ns_frame,
          sizeof(ns_frame),
          physical_if_mac,
          std::nullopt,
          std::nullopt,
          0,  // no error
          ns_frame_translated,
          sizeof(ns_frame_translated),
      },
      {
          "na_frame",
          na_frame,
          sizeof(na_frame),
          guest_if_mac,
          std::nullopt,
          std::nullopt,
          0,  // no error
          na_frame_translated,
          sizeof(na_frame_translated),
      },
  };

  for (const auto& test_case : test_cases) {
    LOG(INFO) << test_case.name;

    size_t packet_len = test_case.input_frame_len - ETHER_HDR_LEN;
    size_t expected_output_packet_len =
        test_case.expected_output_frame_len - ETHER_HDR_LEN;

    memcpy(in_buffer, test_case.input_frame + ETHER_HDR_LEN, packet_len);
    result = NDProxyUnderTest::TranslateNDPacket(
        in_buffer, packet_len, test_case.local_mac, test_case.src_ip,
        test_case.dst_ip, out_buffer);

    if (test_case.expected_error != 0) {
      EXPECT_EQ(test_case.expected_error, result);
    } else {
      EXPECT_EQ(expected_output_packet_len, result);

      const auto expected =
          ToHexString(test_case.expected_output_frame + ETHER_HDR_LEN,
                      expected_output_packet_len);
      const auto received = ToHexString(out_buffer, expected_output_packet_len);
      EXPECT_EQ(expected, received);
    }
  }

  delete[] in_buffer;
  delete[] out_buffer;
}

TEST(NDProxyTest, ResolveDestinationMac) {
  NDProxyUnderTest ndproxy;
  ndproxy.RegisterNeighbor(*net_base::IPv6Address::CreateFromString(
                               "2a01:db8:abc:f605:5c5e:a5ff:fe32:743c"),
                           {0x5e, 0x5e, 0xa5, 0x32, 0x74, 0x3c});
  ndproxy.RegisterNeighbor(
      *net_base::IPv6Address::CreateFromString("ff02::1:ff89:2083"),
      {0x33, 0x33, 0xff, 0x89, 0x20, 0x83});

  struct {
    std::string name;
    std::string dest_ip;
    MacAddress dest_mac;
  } test_cases[] = {
      {"all_nodes", "ff02::1", {0x33, 0x33, 0, 0, 0, 0x01}},
      {"all_routers", "ff02::2", {0x33, 0x33, 0, 0, 0, 0x02}},
      {"solicited_node_1",
       "ff02::1:ff6a:b4d2",
       {0x33, 0x33, 0xff, 0x6a, 0xb4, 0xd2}},
      {"solicited_node_2",
       "ff02::1:ff89:2083",
       {0x33, 0x33, 0xff, 0x89, 0x20, 0x83}},
      {"known_neighbor",
       "2a01:db8:abc:f605:5c5e:a5ff:fe32:743c",
       {0x5e, 0x5e, 0xa5, 0x32, 0x74, 0x3c}},
      {"unknown_neighbor", "fe80::4868:8aff:fedc:b071", {0, 0, 0, 0, 0, 0}},
  };

  for (const auto& test_case : test_cases) {
    LOG(INFO) << test_case.name;
    MacAddress dest_mac;
    const auto dest_ip =
        *net_base::IPv6Address::CreateFromString(test_case.dest_ip);
    ndproxy.ResolveDestinationMac(dest_ip, dest_mac.data());
    const auto expected = MacAddressToString(test_case.dest_mac);
    const auto received = MacAddressToString(dest_mac);
    EXPECT_EQ(expected, received);
  }
}

class MockCallbackHandler {
 public:
  MOCK_METHOD(void, OnGuestDiscovery, (int, const net_base::IPv6Address&));
  MOCK_METHOD(void, OnRouterDiscovery, (int, const net_base::IPv6CIDR&));
};

TEST(NDProxyTest, GuestDiscoveryCallback) {
  uint8_t buffer[IP_MAXPACKET];
  NDProxyUnderTest ndproxy;
  MockCallbackHandler handler;
  ndproxy.RegisterOnGuestIpDiscoveryHandler(base::BindRepeating(
      &MockCallbackHandler::OnGuestDiscovery, base::Unretained(&handler)));
  ndproxy.StartRSRAProxy(1, 1001);

  struct {
    std::string name;
    const uint8_t* input_packet;
    size_t input_packet_len;
    int recv_ifindex;
    bool expect_trigger;
    std::string expected_ip;
  } test_cases[] = {
      {"global_na_on_downstream", global_na_packet, sizeof(global_na_packet),
       1001, true, "2a00:79e1:abc:f605:9406:d4ff:fe06:1258"},
      {"global_na_on_upstream", global_na_packet, sizeof(global_na_packet), 1,
       false, "::"},
      {"global_na_on_other", global_na_packet, sizeof(global_na_packet), 2,
       false, "::"},
      {"local_na_on_downstream", na_frame + ETHER_HDR_LEN,
       sizeof(na_frame) - ETHER_HDR_LEN, 1001, false, "::"},
      {"rs_on_downstream", rs_frame + ETHER_HDR_LEN,
       sizeof(rs_frame) - ETHER_HDR_LEN, 1001, false, "::"},
      {"global_ns_on_downstream", global_ns_packet, sizeof(global_ns_packet),
       1001, true, "2a00:79e1:abc:f605:5c5e:a5ff:fe32:743c"},
      {"global_ns_on_upstream", global_ns_packet, sizeof(global_ns_packet), 1,
       false, "::"},
      {"global_ns_on_other", global_ns_packet, sizeof(global_ns_packet), 2,
       false, "::"},
      {"local_ns_on_downstream", ns_frame + ETHER_HDR_LEN,
       sizeof(ns_frame) - ETHER_HDR_LEN, 1001, false, "::"},
  };

  for (const auto& test_case : test_cases) {
    LOG(INFO) << test_case.name;

    // Copy packet data to a packet-aligned buffer
    memcpy(buffer, test_case.input_packet, test_case.input_packet_len);
    if (test_case.expect_trigger) {
      EXPECT_CALL(handler,
                  OnGuestDiscovery(test_case.recv_ifindex,
                                   *net_base::IPv6Address::CreateFromString(
                                       test_case.expected_ip)));
    } else {
      EXPECT_CALL(handler, OnGuestDiscovery).Times(0);
    }
    ndproxy.NotifyPacketCallbacks(test_case.recv_ifindex, buffer,
                                  test_case.input_packet_len);
  }
}

TEST(NDProxyTest, RouterDiscoveryCallback) {
  uint8_t buffer[IP_MAXPACKET];
  NDProxyUnderTest ndproxy;
  MockCallbackHandler handler;
  ndproxy.RegisterOnRouterDiscoveryHandler(base::BindRepeating(
      &MockCallbackHandler::OnRouterDiscovery, base::Unretained(&handler)));
  ndproxy.StartRSRAProxy(1, 1001);

  struct {
    std::string name;
    const uint8_t* input_packet;
    size_t input_packet_len;
    int recv_ifindex;
    bool expect_trigger;
    std::string expected_cidr;
  } test_cases[] = {
      {"ra_on_upstream", ra_frame + ETHER_HDR_LEN,
       sizeof(ra_frame) - ETHER_HDR_LEN, 1, true, "2401:fa00:4:2::/64"},
      {"ra_on_downstream", ra_frame + ETHER_HDR_LEN,
       sizeof(ra_frame) - ETHER_HDR_LEN, 1001, false, "::/0"},
      {"ra_on_irrelevant", ra_frame + ETHER_HDR_LEN,
       sizeof(ra_frame) - ETHER_HDR_LEN, 2, false, "::/0"},
      {"na_on_upstream", na_frame + ETHER_HDR_LEN,
       sizeof(na_frame) - ETHER_HDR_LEN, 1, false, "::/0"},
      {"rs_on_upstream", rs_frame + ETHER_HDR_LEN,
       sizeof(rs_frame) - ETHER_HDR_LEN, 1, false, "::/0"},
      {"ns_on_upstream", ns_frame + ETHER_HDR_LEN,
       sizeof(ns_frame) - ETHER_HDR_LEN, 1, false, "::/0"},
  };

  for (const auto& test_case : test_cases) {
    LOG(INFO) << test_case.name;

    // Copy packet data to a packet-aligned buffer
    memcpy(buffer, test_case.input_packet, test_case.input_packet_len);
    if (test_case.expect_trigger) {
      EXPECT_CALL(handler,
                  OnRouterDiscovery(test_case.recv_ifindex,
                                    *net_base::IPv6CIDR::CreateFromCIDRString(
                                        test_case.expected_cidr)));
    } else {
      EXPECT_CALL(handler, OnRouterDiscovery).Times(0);
    }
    ndproxy.NotifyPacketCallbacks(test_case.recv_ifindex, buffer,
                                  test_case.input_packet_len);
  }
}

}  // namespace patchpanel
