#!/bin/sh

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script is responsible for suspending and resuming the system.  It is run
# as root by powerd_setuid_helper, which is run by powerd.

. /usr/share/misc/shflags

DEFINE_integer wakeup_count -1 \
    "wakeup event count from start of shutdown. -1 to disable" w
DEFINE_integer suspend_duration -1 \
    "indicates that the system should wakeup after this many seconds" d

# Directory where this script and send_metrics_on_resume (running as root)
# write temporary state files.
root_run_dir=/var/run/power_manager/root

# For testing: write RTC resume timestamp to this file if it exists
timestamp_file=${root_run_dir}/hwclock-on-resume

# File used to record the power status (AC vs. battery) before suspending.  Read
# by send_metrics_on_resume (but only when run after resuming; this doesn't
# need to persist across reboots).
power_status_on_suspend_file=${root_run_dir}/power-status-on-suspend

# File containing resume-related timing information.  Written by
# send_metrics_on_resume and read by autotests; doesn't need to persist
# across reboots.
last_resume_timings_file=${root_run_dir}/last_resume_timings

# Directory where this script (running as root) writes files that must
# persist across reboots.
root_spool_dir=/var/spool/power_manager/root

# File containing the time at which we started suspending.  Read by
# send_metrics_on_resume.
suspend_to_ram_time_file=${root_spool_dir}/suspend-to-ram-time

log_msg() {
    logger -t "powerd_suspend[${PPID}]" -- $@
}

log_msg_from_file() {
    logger -t "powerd_suspend[${PPID}]" -f $1
}

enable_debug() {
    # On some systems (snow), disabling console_suspend does bad things if
    # serial console is enabled. Check if console is non-null and bail out
    # if so.
    if egrep -q "console=\w+" /proc/cmdline; then
        return
    fi

    # Enable debug info.
    if [ -e /sys/module/printk/parameters/console_suspend ]; then
        echo -n 'N' > /sys/module/printk/parameters/console_suspend
    fi
    if [ -e /sys/power/pm_print_times ]; then
        echo -n '1' > /sys/power/pm_print_times
    fi
}

is_lumpy() {
    crossystem hwid | grep -q "LUMPY"
}

has_gobi_modem() {
    # Check if the system has a Novatel Wireless Gobi 3000 E396/E396U modem.
    lsusb -d 1410:a021 || lsusb -d 1410:a023
}

do_lumpy_gobi_modem_revive() {
    # Toggle the power and off GPIOs connected to
    # gobi modem in order to revive it.

    cd /sys/class/gpio

    # TODO (snanda): get the gpio base from crossystem instead
    # of assuming that it will always be 160 for lumpy.
    if [ ! -d gpio198 ]; then
        echo 198 > export
    fi
    if [ ! -d gpio203 ]; then
        echo 203 > export
    fi

    echo out > gpio198/direction
    echo out > gpio203/direction

    echo 1 > gpio203/value
    echo 0 > gpio198/value

    echo 0 > gpio203/value
    echo 1 > gpio198/value
}

# Check pm_wakeup_events status and return success to cancel the suspend
suspend_pm_wakeup_cancel() {
    if [ "${FLAGS_wakeup_count}" -eq -1 ] ||
       echo "${FLAGS_wakeup_count}" > "/sys/power/wakeup_count"; then
        cancel=0
        return 1
    else
        log_msg "Aborting suspend, wake event received"
        cancel=1
        return 0
    fi
}

# Send suspend status to UMA.
#   0 - success
#   1 - failure (in kernel)
#   2 - cancelled
#   3 - attempted
send_uma_status() {
  metrics_client -e Power.SuspendStatus $1 4 &
}

setup_dark_resume() {
    if [ "${FLAGS_suspend_duration}" -ne -1 ]; then
        echo 0 > /sys/class/rtc/rtc0/wakealarm
        echo "+${FLAGS_suspend_duration}" > /sys/class/rtc/rtc0/wakealarm
    fi
}

# Note: Don't change or remove this line without also updating
# send_metrics_on_resume.
log_msg "Going to suspend-to-RAM state : args=$@"

# Parse command line
FLAGS "$@" || exit 1
eval set -- "$FLAGS_ARGV"

send_uma_status 3

# - logs the time going to suspend (no-op if no RTC).
cp /sys/class/rtc/rtc0/since_epoch $suspend_to_ram_time_file \
    2> /dev/null || true

# - Remove last_resume_timings to ensure the file is fresh on resume
rm -f $last_resume_timings_file

# - stores the current power status
power-supply-info 2> /dev/null \
  | /bin/grep -Eq '^[[:space:]]+online:[[:space:]]+no$'
if [ $? -eq 0 ]; then
    echo OnBattery > $power_status_on_suspend_file
else
    echo OnAC > $power_status_on_suspend_file
fi

# Is this a Lumpy system with Gobi modem?
lumpy_with_gobi_modem=0
if is_lumpy && has_gobi_modem; then
    log_msg "Lumpy with gobi modem"
    lumpy_with_gobi_modem=1
fi

enable_debug

log_msg "Explicit sync"
sync

suspend_rc=-1
if suspend_pm_wakeup_cancel; then
    # Note: The client/cros/power_suspend.py module in autotest depends on
    # this message.
    log_msg "Cancel suspend at kernel"

    # This file is usually removed by send_metrics_on_resume, but that script
    # isn't run if the suspend attempt is unsuccessful.
    rm -f $suspend_to_ram_time_file

    # Send suspend status: 2 (cancel)
    send_uma_status 2
else
    log_msg "Finalizing suspend"
    # Make sure that hwclock is cached for when we wake up, this way we don't
    # wait for io and get a more accurate time for wakeup
    # -V prints a little version information and exits, loading .so but not
    # making actual RTC accesses. Do *NOT* change this to a normal execution...
    # it will trigger an RTC interrupt that may count as a wakeup reason, abort
    # your suspend and cause you hours of pain and confusion!
    if [ -f "${timestamp_file}" ]; then
        /sbin/hwclock -V > /dev/null
    else
        # We don't want to overwrite the alarm for whatever test might be
        # running
        setup_dark_resume
    fi

    # - suspends to ram
    echo -n mem > /sys/power/state
    suspend_rc=$?
    if [ "${suspend_rc}" != 0 ]; then
        log_msg "Error writing to /sys/power/state"
        log_msg_from_file /sys/kernel/debug/suspend_stats
    fi

    # Send suspend status: 0 (success) or 1 (failure)
    send_uma_status $suspend_rc
fi

if [ $cancel -eq 0 ]; then
    # On resume:
    if [ -f "${timestamp_file}" ]; then
        # - records the hwclock time at resume. It is read by power_Resume test.
        TIME=$(/sbin/hwclock --utc --debug)
        echo ${TIME} > "${timestamp_file}"
        log_msg "Recorded hwclock time for test"
    fi

    if [ -e "/sys/firmware/log" ]; then
        # Grep /sys/firmware/log for WAK
        wakeup_source=$(grep -A1 -B1 "PM1_STS: WAK" /sys/firmware/log)
        if [ -z "${wakeup_source}" ]; then
            wakeup_source="unknown"
        fi
        log_msg "wake source: ${wakeup_source}"
    fi

    # - sends UMA metrics on resume
    send_metrics_on_resume &

    # Revive the modem if it was present prior to suspending but is absent now.
    if [ $lumpy_with_gobi_modem -eq 1 ]; then
        if ! has_gobi_modem ; then
            log_msg "Reviving lumpy gobi modem"
            do_lumpy_gobi_modem_revive
        fi
    fi
fi

initctl emit system-resumed &

# - refresh mosys eventlog to help feedback reports pick up the latest snapshot
/usr/share/userfeedback/scripts/eventlog &

log_msg "Resume finished"

return $suspend_rc
