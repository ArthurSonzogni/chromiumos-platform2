#!/bin/sh

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

. /usr/share/misc/shflags

DEFINE_boolean test $FLAGS_FALSE "support power_Resume test" t
DEFINE_boolean cancel $FLAGS_FALSE "cancel suspend, but send resume signal" c
DEFINE_integer wakeup_count -1 \
    "wakeup event count from start of shutdown. -1 to disable" w

log_msg() {
    logger -t "powerd_suspend[${PPID}]" $@
}

is_lumpy() {
    crossystem hwid | grep -q "LUMPY"
}

has_gobi_modem() {
    lsusb -d 1410:a021
}

do_lumpy_gobi_modem_revive() {
    # Toggle the power and off GPIOs connected to
    # gobi modem in order to revive it.

    cd /sys/class/gpio

    # TODO (snanda): get the gpio base from crossystem instead
    # of assuming that it will always be 160 for lumpy.
    if [ ! -d gpio198 ]; then
        echo 198 > export
    fi
    if [ ! -d gpio203 ]; then
        echo 203 > export
    fi

    echo out > gpio198/direction
    echo out > gpio203/direction

    echo 1 > gpio203/value
    echo 0 > gpio198/value

    echo 0 > gpio203/value
    echo 1 > gpio198/value
}

# Check pm_wakeup_events status and return success to cancel the suspend
suspend_pm_wakeup_cancel() {
    if [ "${FLAGS_wakeup_count}" -eq -1 ] ||
       echo "${FLAGS_wakeup_count}" > "/sys/power/wakeup_count"; then
        return 1;
    else
        log_msg "Aborting suspend, wake event received"
        return 0;
    fi
}

# these files are created by powerm | powerd and their existence means
# event has occurred which should cancel suspend
suspend_cancel() {
    if [ $FLAGS_cancel -eq $FLAGS_TRUE ] ||
       [ -e "/var/run/power_manager/lid_opened" ] ||
       [ -e "/var/run/power_manager/chronos/user_active" ] ||
       suspend_pm_wakeup_cancel; then
        cancel=1
        return 0
    else
        cancel=0
        return 1
    fi
}

# Send suspend status to UMA.
#   0 - success
#   1 - failure (in kernel)
#   2 - cancelled
#   3 - attempted
send_uma_status() {
  /usr/bin/metrics_client -e Power.SuspendStatus $1 4 &
}

cleanup_for_resume() {
    rm -f "/var/run/power_manager/lid_opened"
    rm -f "/var/run/power_manager/chronos/user_active"
}

log_msg "Going to suspend-to-RAM state : args=$@"
# Parse command line
FLAGS "$@" || exit 1
eval set -- "$FLAGS_ARGV"

send_uma_status 3

# - logs the time going to suspend (no-op if no RTC).
cp /sys/class/rtc/rtc0/since_epoch /var/log/metrics/suspend-to-ram-time \
  2> /dev/null || true

# - announces the event
/usr/bin/dbus-send --type=signal --system /org/chromium/PowerManager \
  org.chromium.PowerManager.PowerStateChanged string:mem int32:0

# - stores the current power status
power_status_on_suspend=/var/log/metrics/power-status-on-suspend
power-supply-info \
  | /bin/grep -Eq '^[[:space:]]+online:[[:space:]]+no$'
if [ $? -eq 0 ]; then
    echo OnBattery > $power_status_on_suspend
else
    echo OnAC > $power_status_on_suspend
fi

# Is this a Lumpy system with Gobi modem?
lumpy_with_gobi_modem=0
if is_lumpy && has_gobi_modem; then
    log_msg "Lumpy with gobi modem"
    lumpy_with_gobi_modem=1
fi

# Disable USB-Persist to save 500ms
# (by not waiting for USB devices to reset and resume)
for i in /sys/bus/usb/devices/*/power/persist; do echo 0 > $i; done

# - deletes hwclock snapshot from previous resumes
rm -f /var/run/power_manager/hwclock-on-resume

# - suspends the cryptohome device
#CRYPTOHOME=/dev/mapper/cryptohome
#/usr/bin/test -b $CRYPTOHOME && /sbin/dmsetup suspend $CRYPTOHOME

log_msg "Explicit sync"
sync

suspend_rc=-1
if suspend_cancel; then
    log_msg "Cancel suspend at kernel"

    # Send suspend status: 2 (cancel)
    send_uma_status 2
else
    log_msg "Finalizing suspend"
    # Make sure that hwclock is cached for when we wake up, this way we don't
    # wait for io and get a more accurate time for wakeup
    if [ $FLAGS_test -eq $FLAGS_TRUE ]; then
        /sbin/hwclock > /dev/null
    fi
    # - suspends to ram
    echo -n mem > /sys/power/state
    suspend_rc=$?
    if [ "${suspend_rc}" != 0 ]; then
        log_msg "Error writing to /sys/power/state"
        log_msg -f /sys/kernel/debug/suspend_stats
    fi

    # Send suspend status: 0 (success) or 1 (failure)
    send_uma_status $suspend_rc
fi

if [ $cancel -eq 0 ]; then
    # On resume:
    if [ $FLAGS_test -eq $FLAGS_TRUE ]; then
        # - records the hwclock time at resume. It is read by power_Resume test.
        TIME=$(/sbin/hwclock --utc --debug)
        echo ${TIME} > /var/run/power_manager/hwclock-on-resume &
        log_msg "Recorded hwclock time for test"
    fi

    if [ -e "/sys/firmware/log" ]; then
        # Grep /sys/firmware/log for WAK
        wakeup_source=$(grep -A1 -B1 "PM1_STS: WAK" /sys/firmware/log)
        if [ -z "${wakeup_source}" ]; then
            wakeup_source="unknown"
        fi
        log_msg "wake source: ${wakeup_source}"
    fi

    # - sends UMA metrics on resume
    /usr/bin/send_metrics_on_resume &

    # Revive the modem if it was present prior to suspending but is absent now.
    if [ $lumpy_with_gobi_modem -eq 1 ]; then
        if ! has_gobi_modem ; then
            log_msg "Reviving lumpy gobi modem"
            do_lumpy_gobi_modem_revive
        fi
    fi
fi

# - announces the event
/usr/bin/dbus-send --type=signal --system /org/chromium/PowerManager \
    org.chromium.PowerManager.PowerStateChanged string:on \
    "int32:${suspend_rc}" &

cleanup_for_resume

#  - re-kicks laptop mode since AC<->Battery transition might've happened
#    while the system was suspended. Sleep a bit, though, to take care of
#    racing with USB stack coming up.
(sleep 10 && /usr/sbin/laptop_mode auto) > /dev/null &

# - resumes cryptohome device
#/usr/bin/test -b $CRYPTOHOME && /sbin/dmsetup resume $CRYPTOHOME

log_msg "Resume finished"
