#!/bin/sh

# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This script collects UMA metrics when the device is coming out of
# suspend or, if the machine shut down while in suspend, at boot time.
#
# Usage:
#   -b -- indicates that this script is invoked at boot time.

# Send a message to /var/log/messages.
# Arguments:
#  $@ - String(s) that you want in the message. If you are having issues with
#  this function, you should read up on how $@ works, since it might be your
#  problem.
log_msg() {
    logger -t "send_metrics_on_resume[${PPID}]" $@
}

# Creates a file based on /var/log/messages containing messages from the most
# recent resume onwards.  This speeds up greps and also makes it possible
# to extract counts (like bitfix) from the most recent resume.
#
# Prints the name of the temp file created.
split_recent_messages() {
  local suspend_start="Going to suspend-to-RAM state"
  local count=$(grep -c "$suspend_start" /var/log/messages)
  local tempdir=$(mktemp --tmpdir -d send_metrics_on_resume.XXXXXXXXXX)

  csplit -s -f $tempdir/recent_messages /var/log/messages \
    "%$suspend_start%" {$((count-1))}

  echo "$tempdir/recent_messages00"
}

# Cleanup files created by split_recent_messages
# Arguments:
#   $1 - Result returned by split_recent_messages()
cleanup_recent_messages() {
  [ -n "$1" ] || return
  local recent_messages="$1"

  /bin/rm "$recent_messages"
  /bin/rmdir $(dirname "$recent_messages")
}

# Sends to UMA the total time since going in suspend:
#   Power.TimeInSuspendAtBoot
#   Power.TimeInSuspendAtResume
# Arguments:
#   $1 - wake-up event: Boot or Resume
send_time_in_suspend() {
  [ -n "$1" ] || return
  local time_in_suspend_name=Power.TimeInSuspendAt$1

  # On suspend, powerd_suspend stores the current RTC value to a file.
  local f_suspend_at=/var/log/metrics/suspend-to-ram-time
  [ -r $f_suspend_at ] || return

  local resume_at=$(/bin/cat /sys/class/rtc/rtc0/since_epoch)
  local suspend_at=$(/bin/cat $f_suspend_at)
  /bin/rm -f $f_suspend_at &
  [ $resume_at -gt $suspend_at ] || return

  # Converts seconds to minutes rounding to the nearest whole minute.
  local time_in_suspend=$((($resume_at - $suspend_at + 30) / 60))
  /usr/bin/metrics_client $time_in_suspend_name $time_in_suspend 1 10000 50 &
}

# Prints the firmware (just BIOS, not including EC) resume time in
# milliseconds.
calculate_firmware_resume_time() {
  # Max CPU frequency, in KHz
  local cpu_freq=$(cat "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq")
  AWK_PROG='
    /TSC at resume: / {
      sub(".*TSC at resume: ", "")
      tsc_at_resume = $0
    }
    END {
      if (tsc_at_resume != 0) {
        printf "%d", int(tsc_at_resume / '$cpu_freq')
      }
    }
  '
  dmesg | awk "$AWK_PROG"
}

# Prints the timestamp of the last occurrence of a specified string in
# the recent messages, or nothing otherwise.
# Arguments:
#   $1 - string to look for
#   $2 - Path to messages for most recent resume onward.
get_last_message_timestamp() {
  [ -n "$1" -a -n "$2" ] || return
  /bin/grep -F "$1" "$2" \
    | /usr/bin/tail -n1 \
    | /bin/sed 's/.*\[\s*\([0-9.]*\)].*/\1/'
}

# Find a message related to the start of suspend and parse out its timestamp. It
# returns the time stamp of the message it found or nothing.
# Arguments:
#   $1 - Path to messages for most recent resume onward.
get_start_suspend_time() {
  [ -n "$1" ] || return

  timestamp=$(get_last_message_timestamp "Freezing user space" "$1")
  [ -n "$timestamp" ] && echo "$timestamp"
}

# Find a message related to the end of suspend and parse out its
# timestamp. Since there are multiple possible messages, this function searches
# for each one in order. It returns the time stamp of the message it found or
# nothing.
# Arguments:
#   $1 - Path to messages for most recent resume onward.
get_end_suspend_time() {
  [ -n "$1" ] || return

  local timestamp=$(get_last_message_timestamp "Back to C!" "$1")
  [ -z "$timestamp" ] &&
    timestamp=$(get_last_message_timestamp "Low-level resume complete" "$1")
  [ -z "$timestamp" ] &&
    timestamp=$(get_last_message_timestamp "Entering suspend state" "$1")
  echo "$timestamp"
}

# Find a message related to the end of resume and parse out its timestamp. Since
# there are multiple possible messages, this function searches for each one in
# order.
# Arguments:
#   $1 - Path to messages for most recent resume onward.
get_end_resume_time() {
  [ -n "$1" ] || return
  timestamp=$(get_last_message_timestamp "Restarting tasks" "$1")
  echo "$timestamp"
}

# Sends to UMA the time it took to suspend and resume:
#   Power.KernelResumeTimeOnAC
#   Power.KernelResumeTimeOnBattery
#   Power.KernelSuspendTimeOnAC
#   Power.KernelSuspendTimeOnBattery
#   Power.FirmwareResumeTimeOnAC
#   Power.FirmwareResumeTimeOnBattery
# Arguments:
#   $1 - Path to messages for most recent resume onward.
send_suspend_resume_time() {
  [ -n "$1" ] || return
  local recent_messages="$1"

  # On suspend, powerd_suspend stores the power status to a file.
  local power_status_on_suspend=/var/log/metrics/power-status-on-suspend
  [ -r $power_status_on_suspend ] || return

  # Greps the timestamps.
  local start_suspend_time=$(get_start_suspend_time "$recent_messages")
  local end_suspend_time=$(get_end_suspend_time "$recent_messages")
  local end_resume_time=$(get_end_resume_time "$recent_messages")

  [ -z "$start_suspend_time" ] && log_msg "Unable to get start_suspend_time"
  [ -z "$end_suspend_time" ] && log_msg "Unable to get end_suspend_time"
  [ -z "$end_resume_time" ] && log_msg "Unable to get end_resume_time"

  # Calculates the time intervals in milliseconds.
  [ -n "$start_suspend_time" ] && [ -n "$end_suspend_time" ] &&
    local kernel_suspend_time=$(echo $start_suspend_time $end_suspend_time |
    /usr/bin/awk '{ if (NF == 2 && $1 < $2) print int(($2 - $1) * 1000) }')
  [ -n "$end_suspend_time" ] && [ -n "$end_resume_time" ] &&
    local kernel_resume_time=$(echo $end_suspend_time $end_resume_time |
    /usr/bin/awk '{ if (NF == 2 && $1 < $2) print int(($2 - $1) * 1000) }')
  local firmware_resume_time=$(calculate_firmware_resume_time)

  [ -z "$firmware_resume_time" ] && log_msg "Unable to get firmware_resume_time"

  # Sends the metrics. Uses the pre-suspend AC status for both suspend
  # and resume since this is the mode that most software is configured
  # at at resume time.
  local ac_status=$(/bin/cat $power_status_on_suspend)
  [ -n "$kernel_suspend_time" ] && /usr/bin/metrics_client \
    Power.KernelSuspendTime$ac_status $kernel_suspend_time 1 10000 50 &
  [ -n "$kernel_resume_time" ] && /usr/bin/metrics_client \
    Power.KernelResumeTime$ac_status $kernel_resume_time 1 10000 50 &
  [ -n "$firmware_resume_time" ] && /usr/bin/metrics_client \
    Power.FirmwareResumeTime$ac_status $firmware_resume_time 1 10000 50 &

  # Cleanup.
  /bin/rm -f $power_status_on_suspend
}

# Find the number of bitfixed chunks
# Arguments:
#   $1 - Path to messages for most recent resume onward.
get_bitfix_chunks() {
  [ -n "$1" ] || return
  grep -c 'bitfix_recover_chunk: Attempting recovery' "$1"
}

# Find the total number of actual fixes
# Arguments:
#   $1 - Path to messages for most recent resume onward.
get_bitfix_fixes() {
  [ -n "$1" ] || return
  grep -c '\.\.\.fixed 0x[0-9a-f]* from 0x[0-9a-f]* to 0x[0-9a-f]*' "$1"
}

# Sends to UMA stats about bitfixes on the most recent suspend/resume:
#   Power.BitfixChunks - Number of 8K chunks fixed
#   Power.BitfixFixes - Number of words fixed
# Arguments:
#   $1 - Path to messages for most recent resume onward.
send_bitfix_metrics() {
  [ -n "$1" ] || return
  local recent_messages="$1"
  local enable_file="/sys/module/bitfix_snow/parameters/bitfix_enabled"

  # Get information about bitfix and send it on.
  if [ "$(cat $enable_file 2>/dev/null)" = "Y" ]; then
    local bitfix_chunks=$(get_bitfix_chunks "$recent_messages")
    local bitfix_fixes=$(get_bitfix_fixes "$recent_messages")
    /usr/bin/metrics_client -e Power.BitfixChunks "$bitfix_chunks" 100 &
    /usr/bin/metrics_client -e Power.BitfixFixes "$bitfix_fixes" 500 &
  fi
}

main() {
  local event="Resume"
  [ "$1" = "-b" ] && event="Boot"
  send_time_in_suspend $event
  if [ $event = "Resume" ]; then
    local recent_messages=$(split_recent_messages)

    send_suspend_resume_time "$recent_messages"
    send_bitfix_metrics "$recent_messages"

    cleanup_recent_messages "$recent_messages"
  fi
}

main $@
