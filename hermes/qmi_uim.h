// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// NOTE: THIS FILE IS AUTOMATICALLY GENERATED - DO NOT MODIFY

#ifndef HERMES_QMI_UIM_H_
#define HERMES_QMI_UIM_H_

#include <cstdint>

#include <base/logging.h>
#include <libqrtr.h>

class QmiUimCommand {
 public:
  enum Code : uint16_t {
    kReset = 0x00,
    kSendApdu = 0x3B,
    kOpenLogicalChannel = 0x42,
    kSwitchSlot = 0x46,
    kGetSlots = 0x47,
  };

  QmiUimCommand(Code code) : code_(code) {}  // NOLINT(runtime/explicit)
  operator Code() const { return code_; }

  const char* ToString() {
    switch (code_) {
      case kReset:
        return "Reset";
      case kSendApdu:
        return "SendApdu";
      case kOpenLogicalChannel:
        return "OpenLogicalChannel";
      case kSwitchSlot:
        return "SwitchSlot";
      case kGetSlots:
        return "GetSlots";
      default:
        CHECK(false) << "Unrecognized value: " << code_;
        return "";
    }
  }

 private:
  Code code_;
};

constexpr int kBufferDataSize = 260;

constexpr int kIccidMaxSize = 20;

struct uim_qmi_result {
  uint16_t result;
  uint16_t error;
};

struct uim_card_result_t {
  uint8_t sw1;
  uint8_t sw2;
};

struct uim_open_logical_channel_req {
  uint8_t slot;
  bool aid_valid;
  uint8_t aid_len;
  uint8_t aid[kBufferDataSize];
};

struct uim_open_logical_channel_resp {
  uim_qmi_result result;
  bool channel_id_valid;
  uint8_t channel_id;
  bool card_result_valid;
  uim_card_result_t card_result;
  bool select_response_valid;
  uint8_t select_response_len;
  uint8_t select_response[kBufferDataSize];
};

struct uim_reset_req {};

struct uim_reset_resp {
  uim_qmi_result result;
};

struct uim_send_apdu_req {
  uint8_t slot;
  uint16_t apdu_len;
  uint8_t apdu[kBufferDataSize];
  bool channel_id_valid;
  uint8_t channel_id;
};

struct uim_send_apdu_resp {
  uim_qmi_result result;
  bool apdu_response_valid;
  uint16_t apdu_response_len;
  uint8_t apdu_response[kBufferDataSize];
};

struct uim_physical_slot_status {
  enum physical_card_status_t : uint32_t {
    kCardUnknown = 0,
    kCardAbsent = 1,
    kCardPresent = 2,
  } physical_card_status;
  enum physical_slot_state_t : uint32_t {
    kSlotInactive = 0,
    kSlotActive = 1,
  } physical_slot_state;
  uint8_t logical_slot;
  uint8_t iccid_len;
  uint8_t iccid[kIccidMaxSize];
};

struct uim_physical_slot_info {
  uint32_t card_protocol;
  uint8_t num_app;
  uint8_t atr_len;
  uint8_t atr[255];
  uint8_t is_euicc;
};

struct uim_get_slots_req {};

struct uim_get_slots_resp {
  uim_qmi_result result;
  bool status_valid;
  uint8_t status_len;
  uim_physical_slot_status status[10];
  bool info_valid;
  uint8_t info_len;
  uim_physical_slot_info info[10];
};

struct uim_switch_slot_req {
  uint8_t logical_slot;
  uint32_t physical_slot;
};

struct uim_switch_slot_resp {
  uim_qmi_result result;
};

extern struct qmi_elem_info uim_open_logical_channel_req_ei[];
extern struct qmi_elem_info uim_open_logical_channel_resp_ei[];
extern struct qmi_elem_info uim_reset_req_ei[];
extern struct qmi_elem_info uim_reset_resp_ei[];
extern struct qmi_elem_info uim_send_apdu_req_ei[];
extern struct qmi_elem_info uim_send_apdu_resp_ei[];
extern struct qmi_elem_info uim_get_slots_req_ei[];
extern struct qmi_elem_info uim_get_slots_resp_ei[];
extern struct qmi_elem_info uim_switch_slot_req_ei[];
extern struct qmi_elem_info uim_switch_slot_resp_ei[];

#endif  // HERMES_QMI_UIM_H_
