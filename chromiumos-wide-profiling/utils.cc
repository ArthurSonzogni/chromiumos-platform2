// Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <openssl/md5.h>
#include <unistd.h>

#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <map>
#include <sstream>
#include <vector>

#include "base/basictypes.h"
#include "base/logging.h"

#include "utils.h"

namespace {

// Specify buffer size to be used to read files.
// This is allocated on the stack, so make sure it's less than 16k.
const int kFileReadSize = 1024;

// Trim leading and trailing whitespace from |str|.
void TrimWhitespace(string* str) {
  const char kWhitespaceCharacters[] = " \t\n\r";
  size_t end = str->find_last_not_of(kWhitespaceCharacters);
  if (end != std::string::npos) {
    size_t start = str->find_first_not_of(kWhitespaceCharacters);
    *str = str->substr(start, end + 1 - start);
  } else {
    // The string contains only whitespace.
    *str = "";
  }
}

// Perf report command and arguments.
// Don't attempt to symbolize:  --symfs=/dev/null
// Use stdio:                   --stdio
// Don't show offsets:          --sort comm,dso
// Use comma as a separator:    -t ,
// Show event count:            -n
// Use subsequent input file:   -i
const char kPerfReportCommand[] =
    "/usr/sbin/perf report --symfs=/dev/null --stdio -n -i ";
const char kPipedPerfReportCommand[] =
    "/usr/sbin/perf report --symfs=/dev/null --stdio --sort comm,dso -t , "
    "-n -i - < ";
const char kPipedPerfReportFromQuipperCommand[] =
    "/usr/sbin/perf report --symfs=/dev/null --stdio --sort comm,dso -t , "
    "-n -i ";

// The piped commands above produce comma-separated lines with the following
// fields:
enum {
  PERF_REPORT_OVERHEAD,
  PERF_REPORT_SAMPLES,
  PERF_REPORT_COMMAND,
  PERF_REPORT_SHARED_OBJECT,
  NUM_PERF_REPORT_FIELDS,
};

const char* kSupportedMetadata[] = {
  "hostname", "os release", "perf version", "arch", "cpudesc"
};

const int kPerfReportParseError = -1;

const char kUnknownDSOString[] = "[unknown]";

const int kUninitializedUnknownValue = -1;

// Tolerance for equality comparison in CompareMapsAccountingForUnknownEntries.
const double kPerfReportEntryErrorThreshold = 0.05;

const char kPerfReportCommentCharacter = '#';

// Given a perf piped data file, get the perf report and read it into a string.
// is_normal_mode should be true if the INPUT file to quipper was in normal
// mode.  Note that a file written by quipper is always in normal mode, but if
// the input to quipper was piped, then is_normal_mode should still be false.
// written_by_quipper should be false for a piped perf data file generated by
// perf record.  It should be true for a data file created by reading and
// writing a piped perf data file through quipper.
bool GetPerfReport(const string& filename, std::vector<string>* output,
                   bool is_normal_mode, bool written_by_quipper) {
  // Redirecting stderr does lose warnings and errors, but serious errors should
  // be caught by the return value of perf report.
  // TODO(sque): Use RunCommandAndGetOutput().
  string cmd;
  if (is_normal_mode)
    cmd = string(kPerfReportCommand);
  else if (written_by_quipper)
    cmd = string(kPipedPerfReportFromQuipperCommand);
  else
    cmd = string(kPipedPerfReportCommand);
  cmd += filename + " 2>/dev/null";

  FILE* file = popen(cmd.c_str(), "r");
  if (!file) {
    LOG(ERROR) << "Could not execute '" << cmd << "'.";
    return false;
  }

  char buffer[kFileReadSize];
  // Read line by line, discarding commented lines.
  // Only keep commented lines of the form
  // #<supported metadata>:
  // Where <supported metadata> is any string in kSupportedMetadata.
  output->clear();
  while (fgets(buffer, sizeof(buffer), file)) {
    bool use_line = false;
    if (buffer[0] != kPerfReportCommentCharacter)
      use_line = true;

    string buffer_string = buffer;
    int length = arraysize(kSupportedMetadata);
    for (int i = 0; i < length; i++) {
      string valid_prefix = string("# ") + kSupportedMetadata[i] + " :";
      if (buffer_string.find(valid_prefix) != string::npos)
        use_line = true;
    }

    if (use_line) {
      TrimWhitespace(&buffer_string);
      output->push_back(buffer_string);
    }
  }

  int status = pclose(file);
  if (status) {
    LOG(ERROR) << "Perf command: '" << cmd << "' returned status: " << status;
    return false;
  };

  return true;
}

// Populates the map using information from the report.
// Returns the index at which the next section begins, or kPerfReportParseError
// to signal an error.
// The report is expected to contain lines in the format
// Overhead,Samples,Command,Shared Object
// And the section ends with the empty string.
int ParsePerfReportSection(const std::vector<string>& report, size_t index,
                           std::map<string, double>* dso_to_overhead,
                           std::map<string, int>* dso_to_num_samples) {
  dso_to_overhead->clear();
  dso_to_num_samples->clear();
  while (index < report.size() && !report[index].empty()) {
    const string& item = report[index++];
    std::stringstream ss(item);
    std::vector<string> tokens;
    std::string token;
    while (std::getline(ss, token, ','))
      tokens.push_back(token);

    if (tokens.size() != NUM_PERF_REPORT_FIELDS)
      return kPerfReportParseError;

    string key = tokens[PERF_REPORT_COMMAND] + "+"
        + tokens[PERF_REPORT_SHARED_OBJECT];
    double overhead = atof(tokens[PERF_REPORT_OVERHEAD].c_str());
    int num_samples = atoi(tokens[PERF_REPORT_SAMPLES].c_str());

    if (overhead == 0.0 || num_samples == 0)
      return kPerfReportParseError;

    CHECK(dso_to_overhead->find(key) == dso_to_overhead->end())
        << "Command + Shared Object " << key << " occurred twice in a section";
    dso_to_overhead->insert(std::pair<string, double>(key, overhead));
    dso_to_num_samples->insert(std::pair<string, int>(key, num_samples));
  }

  // Skip any more empty lines.
  while (index < report.size() && report[index].empty())
    ++index;

  return index;
}

// Compares two maps created by ParsePerfReportSection.
// The input map may contain kUnknownDSOString, but the output map should not.
// class T is used to support ints and doubles.
// Checks the following conditions:
// 1. No key in output_map has a substring kUnknownDSOString.
// 2. Every key in input_map without the kUnknownDSOString substring is also
//    present in output_map.
// 3. The values in input_map and output_map agree with each other.
template <class T>
bool CompareMapsAccountingForUnknownEntries(
    const std::map<string, T>& input_map,
    const std::map<string, T>& output_map) {
  T unknown_value = kUninitializedUnknownValue;
  T output_minus_input = 0;
  typename std::map<string, T>::const_iterator it;

  for (it = input_map.begin(); it != input_map.end(); ++it) {
    string key = it->first;
    if (key.find(kUnknownDSOString) != string::npos) {
      CHECK_EQ(unknown_value, kUninitializedUnknownValue);
      unknown_value = it->second;
    } else if (output_map.find(key) == output_map.end()) {
      return false;
    } else {
      output_minus_input += (output_map.at(key) - it->second);
    }
  }

  // Add any items present in output_map but not input_map.
  for (it = output_map.begin(); it != output_map.end(); ++it) {
    string key = it->first;
    if (key.find(kUnknownDSOString) != string::npos)
      return false;
    else if (input_map.find(key) == input_map.end())
      output_minus_input += it->second;
  }

  // If there were no unknown samples, don't use the error threshold,
  // because in this case the reports should be identical.
  if (unknown_value == kUninitializedUnknownValue)
    return output_minus_input == 0;

  T difference = output_minus_input - unknown_value;
  return (difference < kPerfReportEntryErrorThreshold) &&
         (difference > -kPerfReportEntryErrorThreshold);
}

}  // namespace

namespace quipper {

uint64 Md5Prefix(const string& input) {
  uint64 digest_prefix = 0;
  unsigned char digest[MD5_DIGEST_LENGTH + 1];

  MD5(reinterpret_cast<const unsigned char*>(input.c_str()), input.size(),
      digest);
  // We need 64-bits / # of bits in a byte.
  stringstream ss;
  for( size_t i = 0 ; i < sizeof(uint64) ; i++ )
    // The setw(2) and setfill('0') calls are needed to make sure we output 2
    // hex characters for every 8-bits of the hash.
    ss << std::hex << std::setw(2) << std::setfill('0')
       << static_cast<unsigned int>(digest[i]);
  ss >> digest_prefix;
  return digest_prefix;
}

std::ifstream::pos_type GetFileSize(const string& filename) {
  std::ifstream in(filename.c_str(), std::ifstream::in | std::ifstream::binary);
  in.seekg(0, std::ifstream::end);
  return in.tellg();
}

bool BufferToFile(const string& filename,
                  const std::vector<char> & contents) {
  std::ofstream out(filename.c_str(), std::ios::binary);
  if (out.good())
  {
    out.write(&contents[0], contents.size() * sizeof(contents[0]));
    out.close();
    if (out.good())
      return true;
  }
  return false;
}

bool FileToBuffer(const string& filename, std::vector<char>* contents) {
  contents->reserve(GetFileSize(filename));
  std::ifstream in(filename.c_str(), std::ios::binary);
  if (in.good())
  {
    contents->assign(std::istreambuf_iterator<char>(in),
                     std::istreambuf_iterator<char>());
    if (in.good())
      return true;
  }
  return false;
}

bool CompareFileContents(const string& a, const string& b) {
  struct FileInfo {
    string name;
    std::vector<char> contents;
  };
  FileInfo file_infos[2];
  file_infos[0].name = a;
  file_infos[1].name = b;

  for ( size_t i = 0 ; i < sizeof(file_infos)/sizeof(file_infos[0]) ; i++ ) {
    if(!FileToBuffer(file_infos[i].name, &file_infos[i].contents))
      return false;
  }

  return file_infos[0].contents == file_infos[1].contents;
}

bool CreateNamedTempFile(string * name) {
  char filename[] = "/tmp/XXXXXX";
  int fd = mkstemp(filename);
  if (fd == -1)
    return false;
  close(fd);
  *name = filename;
  return true;
}

bool ComparePerfReports(const string& quipper_input,
                        const string& quipper_output) {
  // Generate a perf report for each file.
  std::vector<string> quipper_input_report, quipper_output_report;
  CHECK(GetPerfReport(quipper_input, &quipper_input_report, true, false));
  CHECK(GetPerfReport(quipper_output, &quipper_output_report, true, true));
  int input_size = quipper_input_report.size();
  int output_size = quipper_output_report.size();

  // Compare the output strings.
  if (input_size != output_size)
    return false;

  for (int i = 0; i < input_size; i++) {
    if (quipper_input_report[i] != quipper_output_report[i])
      return false;
  }

  return true;
}

bool ComparePipedPerfReports(const string& quipper_input,
                             const string& quipper_output) {
  // Generate a perf report for each file.
  std::vector<string> quipper_input_report, quipper_output_report;
  CHECK(GetPerfReport(quipper_input, &quipper_input_report, false, false));
  CHECK(GetPerfReport(quipper_output, &quipper_output_report, false, true));
  int input_size = quipper_input_report.size();
  int output_size = quipper_output_report.size();
  int input_index = 0, output_index = 0;

  // Metadata is only found in the output file.  Make sure it is reasonable.
  string line = quipper_output_report[output_index];
  while (line[0] == kPerfReportCommentCharacter) {
    size_t index_of_colon = line.find(':');
    if (index_of_colon == string::npos)
      return false;

    string field_value = line.substr(index_of_colon + 1);

    // The field should have only ASCII printable characters.
    // ASCII printable characters are found between the space and ~.
    for (size_t i = 0; i < field_value.size(); ++i) {
      if (!isprint(field_value[i]))
        return false;
    }

    line = quipper_output_report[++output_index];
  }

  // Parse each section of the perf report and make sure they agree.
  // See ParsePerfReportSection and CompareMapsAccountingForUnknownEntries.

  while (input_index < input_size && output_index < output_size) {
    std::map<string, double> input_overhead, output_overhead;
    std::map<string, int> input_num_samples, output_num_samples;

    input_index = ParsePerfReportSection(quipper_input_report, input_index,
                                         &input_overhead, &input_num_samples);
    if (input_index == kPerfReportParseError)
      return false;
    output_index = ParsePerfReportSection(quipper_output_report, output_index,
                                          &output_overhead,
                                          &output_num_samples);
    if (output_index == kPerfReportParseError)
      return false;

    if (!CompareMapsAccountingForUnknownEntries(input_overhead,
                                                output_overhead))
      return false;
    if (!CompareMapsAccountingForUnknownEntries(input_num_samples,
                                                output_num_samples))
      return false;
  }

  return (input_index == input_size) && (output_index == output_size);
}

uint64 AlignSize(uint64 size, uint32 align_size) {
  return ((size + align_size - 1) / align_size) * align_size;
}

bool ReadFileToData(const string& filename, std::vector<char>* data) {
  std::ifstream in(filename.c_str(), std::ios::binary);
  if (!in.good()) {
    LOG(ERROR) << "Failed to open file " << filename;
    return false;
  }
  in.seekg(0, in.end);
  size_t length = in.tellg();
  in.seekg(0, in.beg);
  data->resize(length);

  in.read(&(*data)[0], length);

  if (!in.good()) {
    LOG(ERROR) << "Error reading from file " << filename;
    return false;
  }
  return true;
}

bool WriteDataToFile(const std::vector<char>& data, const string& filename) {
  std::ofstream out(filename.c_str(), std::ios::binary);
  out.seekp(0, std::ios::beg);
  out.write(&data[0], data.size());
  return out.good();
}

bool RunCommandAndGetStdout(const string& command, std::vector<char>* output) {
  FILE* fp = popen(command.c_str(), "r");
  if (!fp)
    return false;

  output->clear();
  char buf[kFileReadSize];
  while (!feof(fp)) {
    size_t size_read = fread(buf, 1, sizeof(buf), fp);
    size_t prev_size = output->size();
    output->resize(prev_size + size_read);
    memcpy(&(*output)[prev_size], buf, size_read);
  }
  if (pclose(fp))
    return false;

  return true;
}

}  // namespace quipper
