// Copyright 2015 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
syntax = "proto2";
option optimize_for = LITE_RUNTIME;

package soma;

message SandboxSpec {
  // ------------- Submessage types ----------------------------------------- //
  enum Namespace {
    NEWIPC = 0;
    NEWNET = 1;
    NEWNS = 2;
    NEWPID = 3;
    NEWUSER = 4;
    NEWUTS = 5;
  }

  // These correspond to #defines in linux/capability.h (for 3.14).
  enum LinuxCaps {
    LINUX_CAP_CHOWN = 0;
    LINUX_CAP_DAC_OVERRIDE = 1;
    LINUX_CAP_DAC_READ_SEARCH = 2;
    LINUX_CAP_FOWNER = 3;
    LINUX_CAP_FSETID = 4;
    LINUX_CAP_KILL = 5;
    LINUX_CAP_SETGID = 6;
    LINUX_CAP_SETUID = 7;
    LINUX_CAP_SETPCAP = 8;
    LINUX_CAP_LINUX_IMMUTABLE = 9;
    LINUX_CAP_NET_BIND_SERVICE = 10;
    LINUX_CAP_NET_BROADCAST = 11;
    LINUX_CAP_NET_ADMIN = 12;
    LINUX_CAP_NET_RAW = 13;
    LINUX_CAP_IPC_LOCK = 14;
    LINUX_CAP_IPC_OWNER = 15;
    LINUX_CAP_SYS_MODULE = 16;
    LINUX_CAP_SYS_RAWIO = 17;
    LINUX_CAP_SYS_CHROOT = 18;
    LINUX_CAP_SYS_PTRACE = 19;
    LINUX_CAP_SYS_PACCT = 20;
    LINUX_CAP_SYS_ADMIN = 21;
    LINUX_CAP_SYS_BOOT = 22;
    LINUX_CAP_SYS_NICE = 23;
    LINUX_CAP_SYS_RESOURCE = 24;
    LINUX_CAP_SYS_TIME = 25;
    LINUX_CAP_SYS_TTY_CONFIG = 26;
    LINUX_CAP_MKNOD = 27;
    LINUX_CAP_LEASE = 28;
    LINUX_CAP_AUDIT_WRITE = 29;
    LINUX_CAP_AUDIT_CONTROL = 30;
    LINUX_CAP_SETFCAP = 31;
    LINUX_CAP_MAC_OVERRIDE = 32;
    LINUX_CAP_MAC_ADMIN = 33;
    LINUX_CAP_SYSLOG = 34;
    LINUX_CAP_WAKE_ALARM = 35;
    LINUX_CAP_BLOCK_SUSPEND = 36;
    LINUX_CAP_AUDIT_READ = 37;
  }

  message PortSpec {
    optional bool allow_all = 1;
    repeated uint32 ports = 2;
  }

  message Executable {
    // ----------- Required fields ------------------------------------------ //
    // Command line to run: /path/to/executable [ARGS...]
    repeated string command_line = 1;
    // UID for running the command line.
    optional uint32 uid = 2;
    // GID for running the command line.
    optional uint32 gid = 3;

    // ------------- Optional fields ---------------------------------------- //
    // Will be the CWD when the given executable is run.
    optional string working_directory = 4 [default = "/"];
    // TCP ports allowed for listening.
    optional PortSpec tcp_listen_ports = 5;
    // UDP ports allowed for listening.
    optional PortSpec udp_listen_ports = 6;
    // A whitelist of capabilities to give the application. Defaults to the
    // empty list, no capabilities.
    repeated LinuxCaps capabilities = 7;
  }

  message DevicePathFilter {
    optional string filter = 1;
  }

  message DeviceNodeFilter {
    optional int32 major = 1;  // May be set to -1 to indicate wildcard.
    optional int32 minor = 2;  // May be set to -1 to indicate wildcard.
  }

  message UserACL {
    optional string endpoint_name = 1;
    repeated uint32 uids = 2;
  }

  message GroupACL {
    optional string endpoint_name = 1;
    repeated uint32 gids = 2;
  }

  // ------------- Required fields ------------------------------------------ //
  // Absolute path to the sandbox's filesystem overlay.
  optional string overlay_path = 1;

  // Unique name identifying this SandboxSpec.
  optional string name = 2;

  // Executables to be run inside this sandbox. There must be at least one.
  repeated Executable executables = 3;

  // ------------- Optional fields ------------------------------------------ //

  // List of fully-qualified names of endpoints that should be registered
  // from inside this sandbox.
  repeated string endpoint_names = 4;

  // Namespaces to unshare for the sandbox.
  repeated Namespace namespaces = 5;

  // Path-based filters indicating which device nodes should be visible.
  repeated DevicePathFilter device_path_filters = 6;

  // mknod-number-based filters indicating which device nodes should be visible.
  repeated DeviceNodeFilter device_node_filters = 7;

  // Whether this sandbox should be running at all times or started on-demand.
  optional bool is_persistent = 8;

  repeated UserACL user_acls = 9;
  repeated GroupACL group_acls = 10;

  // When terminating the sandbox, the amount of time to wait after sending
  // SIGTERM before falling back to SIGKILL.
  optional int32 shutdown_timeout_ms = 11 [default = 100];
}
