// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "vm_tools/notificationd/notification_shell_client.h"

#include <memory>
#include <string>
#include <utility>

#include <base/bind.h>
#include <base/bind_helpers.h>
#include <base/logging.h>
#include <base/memory/ptr_util.h>
#include <base/threading/thread_task_runner_handle.h>
#include <wayland-client.h>
#include <wayland-util.h>

namespace vm_tools {
namespace notificationd {

NotificationShellClient::NotificationShellClient(base::Closure quit_closure)
    : quit_closure_(std::move(quit_closure)) {}

void NotificationShellClient::OnFileCanReadWithoutBlocking(int fd) {
  DCHECK_EQ(event_loop_fd_.get(), fd);

  if (wl_event_loop_dispatch(event_loop_.get(), 0) < 0) {
    PLOG(ERROR) << "Failed to dispatch event loop for wayland";
    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, quit_closure_);
  }
}

void NotificationShellClient::OnFileCanWriteWithoutBlocking(int fd) {
  NOTREACHED();
}

// static
std::unique_ptr<NotificationShellClient> NotificationShellClient::Create(
    const std::string& display_name, base::Closure quit_closure) {
  auto client =
      base::WrapUnique(new NotificationShellClient(std::move(quit_closure)));

  if (!client->Init(display_name.empty() ? nullptr : display_name.c_str()))
    return nullptr;

  return client;
}

bool NotificationShellClient::Init(const char* display_name) {
  event_loop_.reset(wl_event_loop_create());
  event_loop_fd_.reset(wl_event_loop_get_fd(event_loop_.get()));
  if (!event_loop_fd_.is_valid()) {
    PLOG(ERROR) << "Could not get wayland event loop fd";
    return false;
  }

  const bool ret = base::MessageLoopForIO::current()->WatchFileDescriptor(
      event_loop_fd_.get(), true /*persistent*/,
      base::MessageLoopForIO::WATCH_READ, &watcher_, this);
  if (!ret) {
    LOG(ERROR) << "Failed to watch event loop fd";
    return false;
  }

  display_.reset(wl_display_connect(display_name));

  if (!display_) {
    LOG(ERROR) << "Failed to connect to the display";
    return false;
  }

  wl_event_loop_add_fd(event_loop_.get(), wl_display_get_fd(display_.get()),
                       WL_EVENT_READABLE, HandleEventCallback, this);

  wl_registry_add_listener(wl_display_get_registry(display_.get()),
                           &registry_listener_, this);
  wl_display_roundtrip(display_.get());

  if (!proxy_) {
    LOG(ERROR) << "Server is missing the zcr_notification_shell_v1 interface";
    return false;
  }

  return true;
}

bool NotificationShellClient::SendNotification(
    const std::string& title,
    const std::string& message,
    const std::string& display_source,
    const std::string& notification_key) {
  DCHECK(proxy_);

  // zcr_notification_shell_v1_create_notification method is automatically
  // generated by wayland-scanner according to the
  // vm_tools/notificationd/protocol/notification-shell-unstable-v1.xml
  zcr_notification_shell_v1_create_notification(
      proxy_.get(), title.c_str(), message.c_str(), display_source.c_str(),
      notification_key.c_str());

  wl_display_flush(display_.get());
  return true;
}

void NotificationShellClient::HandleRegistry(wl_registry* registry,
                                             int32_t id,
                                             const char* interface,
                                             uint32_t version) {
  if (std::string(interface) == "zcr_notification_shell_v1") {
    proxy_.reset(static_cast<zcr_notification_shell_v1*>(wl_registry_bind(
        registry, id, &zcr_notification_shell_v1_interface, 1)));
  }
}

int NotificationShellClient::HandleEvent(uint32_t mask) {
  if (mask & WL_EVENT_HANGUP) {
    LOG(ERROR) << "Wayland connection hung up";
    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, quit_closure_);
    return -1;
  }
  if (mask & WL_EVENT_ERROR) {
    LOG(ERROR) << "Wayland connection error occurred";
    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, quit_closure_);
    return -1;
  }

  int count = 0;
  if (mask & WL_EVENT_READABLE)
    count = wl_display_dispatch(display_.get());

  if (mask == 0) {
    count = wl_display_dispatch_pending(display_.get());
    wl_display_flush(display_.get());
  }

  return count;
}

int NotificationShellClient::HandleEventCallback(int fd,
                                                 uint32_t mask,
                                                 void* data) {
  return static_cast<vm_tools::notificationd::NotificationShellClient*>(data)
      ->HandleEvent(mask);
}

void NotificationShellClient::HandleRegistryCallback(void* data,
                                                     wl_registry* registry,
                                                     uint32_t id,
                                                     const char* interface,
                                                     uint32_t version) {
  static_cast<vm_tools::notificationd::NotificationShellClient*>(data)
      ->HandleRegistry(registry, id, interface, version);
}

}  // namespace notificationd
}  // namespace vm_tools
