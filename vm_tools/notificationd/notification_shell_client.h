// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef VM_TOOLS_NOTIFICATIOND_NOTIFICATION_SHELL_CLIENT_H_
#define VM_TOOLS_NOTIFICATIOND_NOTIFICATION_SHELL_CLIENT_H_

#include <memory>
#include <string>

#include <base/files/scoped_file.h>
#include <base/macros.h>
#include <base/message_loop/message_loop.h>
#include <wayland-server.h>

#include "notification-shell-unstable-v1-client-protocol.h"  // NOLINT(build/include)

namespace vm_tools {
namespace notificationd {

// Handles notification shell protocol as Wayland client.
class NotificationShellClient : public base::MessageLoopForIO::Watcher {
 public:
  // Creates and returns a NotificationShellClient. Returns nullptr if the the
  // client failed to be initialized and be connected to the compositor for any
  // reason.
  static std::unique_ptr<NotificationShellClient> Create(
      const std::string& display_name, base::Closure quit_closure);

  ~NotificationShellClient() = default;

  // Sends create_notification request to Wayland server which this client
  // is connected to. Returns true on success. Arguments for this method must be
  // synchronized with the notification shell spec in
  // vm_tools/notificationd/protocol/notification-shell-unstable-v1.xml.
  bool SendNotification(const std::string& title,
                        const std::string& message,
                        const std::string& display_source,
                        const std::string& notification_key);

 private:
  struct WlEventLoopDeleter {
    void operator()(wl_event_loop* loop) { wl_event_loop_destroy(loop); }
  };
  using WlEventLoop = std::unique_ptr<wl_event_loop, WlEventLoopDeleter>;

  struct WlDisplayDeleter {
    void operator()(wl_display* display) { wl_display_disconnect(display); }
  };
  using WlDisplay = std::unique_ptr<wl_display, WlDisplayDeleter>;

  struct NotificationProxyDeleter {
    void operator()(zcr_notification_shell_v1* proxy) {
      // zcr_notification_shell_v1_destroy method is automatically generated by
      // wayland-scanner according to the
      // vm_tools/notificationd/protocol/notification-shell-unstable-v1.xml.
      zcr_notification_shell_v1_destroy(proxy);
    }
  };
  using NotificationProxy =
      std::unique_ptr<zcr_notification_shell_v1, NotificationProxyDeleter>;

  explicit NotificationShellClient(base::Closure quit_closure);

  // Initializes the Wayland client. Returns true on success.
  bool Init(const char* display_name);

  // base::MessageLoopForIO::Watcher overrides.
  void OnFileCanReadWithoutBlocking(int fd) override;
  void OnFileCanWriteWithoutBlocking(int fd) override;

  // Handles registry event. Called from event handler for wayland-client
  // library. Called from the wrapper (HandleRegistryCallback), which is
  // compatible with wayland-client library's callback signature.
  void HandleRegistry(wl_registry* registry,
                      int32_t id,
                      const char* interface,
                      uint32_t version);

  // Handles events for display. Returns the number of dispatched events on
  // success or -1 on failure. Called from the wrapper (HandleEventCallback),
  // which is compatible with wayland-client library's callback signature.
  int HandleEvent(uint32_t mask);

  // Wrapper for wayland event handlers. Called from wayland-client library.
  static int HandleEventCallback(int fd, uint32_t mask, void* data);
  static void HandleRegistryCallback(void* data,
                                     wl_registry* registry,
                                     uint32_t id,
                                     const char* interface,
                                     uint32_t version);

  const wl_registry_listener registry_listener_ = {HandleRegistryCallback,
                                                   nullptr};

  // Event loop for handling Wayland event callbacks.
  WlEventLoop event_loop_;

  // File discriptor of the wayland event loop.
  base::ScopedFD event_loop_fd_;
  base::MessageLoopForIO::FileDescriptorWatcher watcher_;

  // Wayland display for the host.
  WlDisplay display_;

  // Wayland proxy for notification interface.
  NotificationProxy proxy_;

  base::Closure quit_closure_;

  DISALLOW_COPY_AND_ASSIGN(NotificationShellClient);
};

}  // namespace notificationd
}  // namespace vm_tools

#endif  // VM_TOOLS_NOTIFICATIOND_NOTIFICATION_SHELL_CLIENT_H_
