// Copyright 2023 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <algorithm>
#include <cstdint>
#include <optional>
#include <set>
#include <string>

#include <base/files/file_path.h>
#include <base/files/file_util.h>
#include <base/json/json_reader.h>
#include <base/json/json_writer.h>
#include <base/logging.h>
#include <base/values.h>
#include <brillo/data_encoding.h>
#include <google/protobuf/util/json_util.h>
#include <rootdev/rootdev.h>
#include <vboot/vboot_host.h>

#include "libsegmentation/device_info.pb.h"
#include "libsegmentation/feature_management.h"
#include "libsegmentation/feature_management_impl.h"
#include "libsegmentation/feature_management_interface.h"
#include "libsegmentation/feature_management_util.h"

#include "proto/feature_management.pb.h"

// Autogenerated by feature-management-data,
// Contains protobuf definitions.
#include <libsegmentation/libsegmentation_pb.h>

using chromiumos::feature_management::api::software::Feature;

namespace segmentation {

// Sysfs file corresponding to VPD state. This will be used to persist device
// info state and read cache device info state.
constexpr const char kVpdSysfsFilePath[] =
    "/sys/firmware/vpd/rw/feature_device_info";

#if USE_FEATURE_MANAGEMENT
// Sysfs file corresponding to VPD state. This will be used to persist device
// info state and read cache device info state.
const char* kDeviceInfoFilePath = kVpdSysfsFilePath;
#else
constexpr char kDeviceInfoFilePath[] = "";

FeatureManagementInterface::FeatureLevel
FeatureManagementImpl::GetFeatureLevel() {
  return FeatureLevel::FEATURE_LEVEL_0;
}

FeatureManagementInterface::ScopeLevel FeatureManagementImpl::GetScopeLevel() {
  return ScopeLevel::SCOPE_LEVEL_0;
}

#endif

FeatureManagementImpl::FeatureManagementImpl()
    : FeatureManagementImpl(base::FilePath(kDeviceInfoFilePath),
                            protobuf_features) {}

FeatureManagementImpl::FeatureManagementImpl(
    const base::FilePath& device_info_file_path, const char* feature_db)
    : device_info_file_path_(device_info_file_path) {
  persist_via_vpd_ =
      device_info_file_path_ == base::FilePath(kVpdSysfsFilePath);
  std::string decoded_pb;
  brillo::data_encoding::Base64Decode(feature_db, &decoded_pb);
  bundle_.ParseFromString(decoded_pb);
}

bool FeatureManagementImpl::IsFeatureEnabled(const std::string& name) {
  int prefix_len = strlen(FeatureManagement::kPrefix);
  if (name.compare(0, prefix_len, FeatureManagement::kPrefix))
    return false;

  auto level = GetFeatureLevel();
  if (level == FEATURE_LEVEL_UNKNOWN)
    level = FEATURE_LEVEL_0;

  std::string in_feature = name.substr(prefix_len);
  for (auto feature : bundle_.features()) {
    if (!feature.name().compare(in_feature))
      return level >= feature.feature_level() + FEATURE_LEVEL_VALID_OFFSET;
  }
  return false;
}

const std::set<std::string> FeatureManagementImpl::ListFeatures(
    const FeatureUsage usage) {
  auto level = GetFeatureLevel();
  if (level == FEATURE_LEVEL_UNKNOWN)
    level = FEATURE_LEVEL_0;

  std::set<std::string> features;
  for (auto feature : bundle_.features()) {
    if (std::find(feature.usages().begin(), feature.usages().end(), usage) !=
            feature.usages().end() &&
        level >= feature.feature_level() + FEATURE_LEVEL_VALID_OFFSET)
      features.emplace(FeatureManagement::kPrefix + feature.name());
  }
  return features;
}
}  // namespace segmentation
