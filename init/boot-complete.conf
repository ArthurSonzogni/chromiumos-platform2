# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# boot-complete
#
# Processing required during boot after login prompt is displayed.
# Primarily, this means calculating boot time statistics.

start on login-prompt-ready

task

script
  # The login-prompt-ready signal is emitted every time the login
  # screen is displayed so the check below makes sure boot stats are
  # generated only once per boot.
  [ -f /tmp/uptime-login-prompt-ready ] && exit

  # If ureadahead is still running, then presumably it's performing
  # a boot trace.  We only care about tracing until login prompt, so
  # stop the process now.
  #
  # We use the "|| true" to prevent killing the job in the case that
  # we weren't tracing, because in that case the ureadahead process
  # likely has completed, and pkill helpfully exits with a non-zero
  # status when no process was found.
  pkill '^ureadahead$' || true

  UPTIME_STATS=`cat /proc/uptime`
  DRIVE=`rootdev -d`
  DRIVE=${DRIVE##/dev/}
  DISK_STATS=`cat /sys/block/${DRIVE}/stat`

  BOOT_TIME=`echo $UPTIME_STATS | cut -f 1 -d ' '`
  SECTORS_READ=`echo $DISK_STATS | cut -f 3 -d ' '`
  SECTORS_WRITTEN=`echo $DISK_STATS | cut -f 7 -d ' '`

  INITIAL_TSC=`fgrep 'Initial TSC value:' /var/log/messages \
                 | tail -1 \
                 | sed 's,.\+Initial TSC value: \([0-9]\+\)$,\1,'`
  PROCESSOR_MHZ=`fgrep ' MHz processor.' /var/log/messages \
                   | tail -1 \
                   | sed 's,.\+Detected \([0-9.]\+\) MHz processor\.$,\1,'`
  FIRMWARE_BOOT_TIME=`echo $INITIAL_TSC $PROCESSOR_MHZ \
                        | awk '{ if (NF == 2) print $1 / $2 / 1000000 }'`

  if [ -n "$FIRMWARE_BOOT_TIME" ]; then
    BOOT_TIME=`echo $BOOT_TIME $FIRMWARE_BOOT_TIME | awk '{ print $1 + $2 }'`
    echo $FIRMWARE_BOOT_TIME > /tmp/firmware-boot-time
  fi

  # All boot times (including firmware and total boot time) are
  # currently sent to UMA from Chrome.
  /usr/bin/metrics_client \
    Platform.BootSectorsRead $SECTORS_READ 1 1000000 50 &
  /usr/bin/metrics_client \
    Platform.BootSectorsWritten $SECTORS_WRITTEN 1 10000 50 &

  # Checks if the device shut down while in suspend and sends metrics
  # as if coming out of suspend.
  /usr/bin/send_metrics_on_resume -b &
  
  echo $UPTIME_STATS > /tmp/uptime-login-prompt-ready
  echo $DISK_STATS > /tmp/disk-login-prompt-ready
end script
