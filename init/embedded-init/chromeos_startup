#!/bin/sh

# Copyright (c) 2013 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# The kernel mounts /proc, /sys and /dev during initialization, prior
# to starting init.

mount -n -t tmpfs -o nodev,noexec,nosuid tmp /tmp
# Mount debugfs as crossystem requires chromeos_arm driver interface.
mount -n -t debugfs -o nodev,noexec,nosuid,mode=0750,uid=0,gid=debugd debugfs \
  /sys/kernel/debug

mkdir -p /dev/shm /dev/pts
mount -n -t tmpfs -o nodev,noexec,nosuid shmfs /dev/shm
mount -n -t devpts -o noexec,nosuid,gid=5,mode=0620 devpts /dev/pts

# Initialize kernel sysctl settings early so that they take effect for boot
# processes.
sysctl -q -p /etc/sysctl.conf

# Prepare to mount stateful partition
ROOT_DEV=$(rootdev -s)
ROOTDEV_RET_CODE=$?
ROOTDEV_TYPE=${ROOT_DEV%[0-9]*}
# Check if we are booted on physical media. rootdev will fail if we are in
# an initramfs or tmpfs rootfs (used for x86 factory images). When using
# initrd+tftpboot (used for ARM factory images), ROOTDEV_TYPE will be
# /dev/ram.
if [ "$ROOTDEV_RET_CODE" = "0" -a "$ROOTDEV_TYPE" != "/dev/ram" ]; then
  # Find our stateful partition. It's always partition 1.
  STATE_DEV=${ROOTDEV_TYPE}1

  # For factory install shim, we never want to write to the SDCard.
  # In some cases, we boot the factory install shim directly from removable
  # media like an SDCard. In those cases we don't want to write to that
  # removable media.
  if [ -f /root/.factory_installer ]; then
    mount -n -t tmpfs -o nodev,noexec,nosuid,mode=0755 tmp \
      /mnt/stateful_partition
    # Fetch our writeable lsb-release from the stateful
    # partition if available.
    TMP_STATEFUL="$(mktemp -d)"
    FACTORY_LSB_REL="dev_image/etc/lsb-factory"
    mkdir -p /mnt/stateful_partition/dev_image/etc
    mount -n -t ext4 -o nodev,noexec,nosuid,commit=600 \
      "$STATE_DEV" "$TMP_STATEFUL"
    if [ -f "${TMP_STATEFUL}/${FACTORY_LSB_REL}" ]; then
      cp -a "${TMP_STATEFUL}/${FACTORY_LSB_REL}" \
        /mnt/stateful_partition/${FACTORY_LSB_REL}
    fi
    umount "$TMP_STATEFUL"
    rmdir "$TMP_STATEFUL"

  # For all other cases, mount stateful partition from STATE_DEV.
  elif ! mount -n -t ext4 -o nodev,noexec,nosuid,commit=600 \
         "$STATE_DEV" /mnt/stateful_partition; then
    # Try to rebuild the stateful partition by  clobber-state
    # (for security concern, we don't use fast mode)
    chromeos-boot-alert self_repair /dev/tty1
    clobber-log --repair "$STATE_DEV" "Self-repair corrupted stateful partition"
    exec clobber-state "keepimg"
  fi

  # Mount the OEM partition.
  # mount_or_fail isn't used since this partition only has a filesystem
  # on some boards.
  OEM_DEV=${ROOTDEV_TYPE}8
  mount -n -t ext4 -o nodev,noexec,nosuid,commit=600,ro \
    "$OEM_DEV" /usr/share/oem
fi

# Sanity check the date (crosbug.com/13200)
if [ $(date +%Y) -lt 1970 ]; then
  date 010200001970.00
fi

# A bunch of dev mode, debug stuff.  Stateful update, firmware update, etc.

# Make sure unencrypted stateful partition has the needed directories.
for d in home home/chronos home/root home/user \
         unencrypted/cache unencrypted/preserve var; do
  mkdir -p -m 0755 /mnt/stateful_partition/$d
done

# Mount /home.  This mount inherits nodev,noexec,nosuid from
# /mnt/stateful_partition above.
# got rid of using mount_or_fail
mount -n --bind /mnt/stateful_partition/home /home
mount -n --bind /mnt/stateful_partition/var /var

# Make sure required /var subdirectories exist.
mkdir -p -m 0755 /var/cache /var/db /var/empty /var/lib/ureadahead \
                 /var/lock /var/log/metrics /var/run /var/tmp

# /var/tmp must be world-writable and sticky
chmod 1777 /var/tmp
# /home/root must be group-writable and sticky
chmod 1771 /home/root
# Selected directories must belong to the chronos user.
chown chronos:chronos /home/chronos /var/log/metrics
# rsyslog needs to be able to create new logfiles, but not delete other logs
chgrp syslog /var/log
chmod 1775 /var/log

# got rid of using mount_or_fail
mount -n -t tmpfs -o mode=0755,nodev,noexec,nosuid varrun /var/run
touch /var/run/.ramfs  # TODO: Is this needed?
mount -n -t tmpfs -o mode=1777,nodev,noexec,nosuid varlock /var/lock
touch /var/lock/.ramfs # TODO: Is this needed?
mount -n -t tmpfs -o nodev,noexec,nosuid media /media

# Mount stateful partition for dev packages
# TODO(arkaitzr@chromium.org) - Only use CROS_DEBUG when cros_debug is
# correctly set in a test VM after updating itself to itself (that is, it does
# not fail cros_au_test_harness).
if [ "$CROS_DEBUG" = "1" -o -f /root/.dev_mode ]; then
  # Capture a snapshot of "normal" mount state here, for auditability,
  # before we start applying devmode-specific changes.
  cat /proc/mounts > /var/log/mount_options.log
  # Create dev_image directory in base images in developer mode.
  if [ ! -d /mnt/stateful_partition/dev_image ]; then
    mkdir -p -m 0755 /mnt/stateful_partition/dev_image
  fi
  # Mount and then remount to enable exec/suid.
  mount -n --bind /mnt/stateful_partition/dev_image /usr/local
  mount -n -o remount,exec,suid /usr/local

  # Set up /var elements needed by gmerge.
  # TODO(keescook) Use dev/test package installs instead of piling more
  # things here (crosbug.com/14091).
  BASE=/mnt/stateful_partition/var_overlay
  if [ -d ${BASE} ]; then
    # Keep this list in sync with the var_overlay elements in the DIRLIST
    # found in chromeos-install from chromeos-base/chromeos-installer.
    DIRLIST="
      db/pkg
      lib/portage
    "
    for DIR in ${DIRLIST}; do
      if [ ! -d ${BASE}/${DIR} ]; then
        continue
      fi
      DEST=/var/${DIR}
      if [ -e ${DEST} ]; then
        continue
      fi
      PARENT=$(dirname ${DEST})
      mkdir -p ${PARENT}
      ln -sf ${BASE}/${DIR} ${DEST}
    done
  fi
fi

# Always return success to avoid killing init
exit 0
