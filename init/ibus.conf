# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

description   "Run ibus-daemon and ibus-memconf"
author        "chromium-os-dev@googlegroups.com"

start on x-started
stop on stopping ui
respawn

# Uncomment this to turn on IBus logs.
# env ENABLE_IBUS_LOGGING=yes

env XAUTHORITY=/home/chronos/.Xauthority
env DISPLAY=:0.0
env MINIJAIL_FLAGS="--use-capabilities"
# might be overridden by --uid parameter in /sbin/session_manager_setup.sh
env USER_ID=1000
# ibus-daemon creates a temporary file in /home/chronos,
# not in /home/chronos/user.
env HOME=/home/chronos
# By default, libdbus treats all warnings as fatal errors. That's too strict.
env DBUS_FATAL_WARNINGS=0

script
# ibus checks this env variable to get the UID of the calling user.  It is
# meant for cases where userhelper is used, but it seems to be needed for us.
export USERHELPER_UID=${USER_ID}

# Enable the crash dumper for ibus-daemon and its sub processes.
export LD_PRELOAD=/usr/lib/libcrash.so

# Start ibus-daemon and ibus-memconf. We do not start candidate_window process
# here. The process is started on login-prompt-ready event.
if [ -n "$ENABLE_IBUS_LOGGING" ] ; then
  exec /sbin/minijail ${MINIJAIL_FLAGS} --uid=${USER_ID} -- \
    /usr/bin/ibus-daemon --restart --panel=disable --cache=none \
    --verbose 1> /var/log/ibus.log 2>&1
else
  exec /sbin/minijail ${MINIJAIL_FLAGS} --uid=${USER_ID} -- \
    /usr/bin/ibus-daemon --restart --panel=disable --cache=none
fi
# TODO(yusukes): Replace '--panel=disable' with '--single' so ibus-daemon does
# not start ibus-memconf if crosbug.com/4060 is implemented.
end script

# Wait until ibus-memconf starts to ensure that the Chrome login screen
# (src/chrome/browser/chromeos/login/*.cc) could connect to ibus-daemon to
#  (a) get the list of supported input methods, and
#  (b) change the current input method. 
# Note that ibus-daemon does the following in this order when it starts:
#   1. fork and daemonize ibus-daemon in main() (when --daemonize is passed.) 
#   2. get the list of supported input methods in bus_server_get_default().
#   3. write the socket file (~/.config/ibus/bus/*-unix-0) in bus_server_listen.
#   4. spawn the ibus-memconf process.
# The post-start script waits for 4. since (a) requires 3. and (b) does 4.
post-start script
  set +e  # pgrep might return non-zero.

# Wait for ibus-memconf daemon for up to 1.5 seconds. If it takes more than 1.5
# seconds to start ibus-daemon and ibus-memconf, a correct keyboard layout for
# the login screen (e.g. US Dvorak) might not be activated, but we're assuming
# it's better to continue at that point without ibus rather than loop
# indefinitely.
  for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do

# TODO(yusukes): Replace the pgrep with 'if [ -s /path_to_ibus_socket/*unix-0 ]'
# if ibus-memconf is removed (crosbug.com/4060).
# TODO(yusukes): To be exact, "pgrep ibus-memconf returned non-zero" does not
# always guarantee that Chrome login screen can communicate with the process
# since the process might be suspended by the OS before it registers itself to
# ibus-daemon. We should use better synchronization method, or move the config
# daemon functionality to Chrome (crosbug.com/4060).
    pgrep ibus-memconf
    if [ $? -eq 0 ] ; then
      exit 0
    fi
    sleep .1
  done

# ibus-daemon or ibus-memconf did not start in 1.5 seconds. Write a log message
# like 'init: ibus post-start process (NNNN) terminated with status 255' to
# /var/log/messages.
  exit 255
end script

post-stop script

set +e
. /sbin/killers

# Ensure sub-processes of ibus-daemon are terminated. Note that these processes
# are not mananged by Upstart.
term_process "(candidate_w.*|ibus-[em].*)"

# Since Chrome OS regenerates /var/lib/dbus/machine-id every time when the OS
# starts, ibus-daemon creates a new file in ${HOME}/.config/ibus/bus/ every time
# when it starts. It's better to remove them when ibus-daemon is terminated.
rm -f ${HOME}/.config/ibus/bus/*

end script
