#!/bin/sh

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Provides alert messages in boot stage, called by chromeos_startup.

# Since this script only provides messages, never abort.
set +e

# Prints usage help for commands supports
usage_help() {
  echo "Usage: $0 mode terminal [arg ...]

  warn_dev: Message for warning about developer mode on normal firmware.
            Arg #1: (optional, default=30) Countdown in seconds before continue

  enter_dev: Message for entering developer mode from non-dev.
             Arg #1: (optional, default=30) Countdown in seconds before continue

  leave_dev: Message when leaving developer mode.
             Arg: none

  update_firmware: Message before starting firmware update.
             Arg: none

  wipe:      Message when starting to erase stateful partition.
             Arg #1: (optional) Image file to show.

  self_repair: Message when starting to rebuild stateful partition.

  dev_fwcheck: Message when staring with developer firmware, to check if there
               is available updates.
"
}

# Prints out system locale by searching cached settings or VPD.
find_current_locale() {
  # TODO(hungte) Find some better way other than hard coding file path here.
  local state_file='/mnt/stateful_partition/home/chronos/Local State'
  local vpd_file='/mnt/stateful_partition/var/log/vpd_2.0.txt'
  local locale=""
  if [ -f "$state_file" ]; then
    locale="$(grep -w '"app_locale":' "$state_file" |
              sed 's/.*"\([^"]*\)",$/\1/')" || locale=""
  fi
  if [ -n "$locale" ]; then
    echo "$locale"
  elif [ -f "$vpd_file" ]; then
    sed -nr '/^"initial_locale"=".*"/s/.*="(.*)"/\1/p' "$vpd_file"
  else
    vpd -i RO_VPD -g initial_locale 2>/dev/null || true
  fi
}

# Shows PNG message-type image files on screen center if available.
# Arguments: message name in /usr/share/chromeos-assets/images/messages/$locale
show_assets_message_image() {
  local message="$1"
  local locale locale_list image_file

  # Build locale list
  locale="$(find_current_locale)" || locale=""
  locale_list="$locale"
  while [ "${locale%[-_]*}" != "$locale" ]; do
    locale="${locale%[-_]*}"
    locale_list="$locale_list $locale"
  done
  locale_list="$locale_list en-US en"

  for locale in $locale_list; do
    image_file="/usr/share/chromeos-assets/images/messages/$locale/$message.png"
    if [ -f "$image_file" ]; then
      ply-image "$image_file" >/dev/null 2>&1 || return $?
      return 0
    fi
  done
  return 1
}

# Prints the two byte hex code of the matched char or
# exists non-zero on timeout.  It reads from the current tty.
# To override, call it as follows,
#   match_char_timeout args < "$STDOUT"
#
# Arguments: time_in_seconds two_byte_hex_match_1 two_byte_hex_match_2 ...
match_char_timeout() {
  local delay_secs="$1"
  shift

  local input=''
  local match=''
  local start_time=$(date +%s)
  local stop_time=$((start_time + delay_secs))
  local tty_config=$(stty -g)
  stty raw -echo
  while [ $delay_secs -gt 0 ]; do
    input=$(timeout -s KILL ${delay_secs}s head -c 1)
    [ $? -eq 137 ] && break  # Timed out.
    input=$(printf "%02x" "'$input")
    for char in "$@"; do
      if [ "$input" = "$char" ]; then
        match="$input"
        break
      fi
    done
    [ -n "$match" ] && break
    delay_secs=$((stop_time - $(date +%s) ))
  done
  # Restores the tty's settings.
  stty $tty_config

  [ -z "$match" ] && return 1
  printf "$match"
  return 0
}

# Prints message when in developer mode
# Argument: time to countdown (in seconds)
mode_warn_dev() {
  local delay_secs="${1:-30}"
  # Don't show a broken/partial background image.
  tput clear > "$STDOUT"
  echo '






                        __________________________
                       |.------------------------.|
                       ||                        ||
                       ||    (_)          (_)    ||
                       ||                        ||
                       ||       __________       ||
                       ||     /            \     ||
                       ||________________________||
                      / __/___/_____________\__\__ \
                     /               _              \
                    /        /_______\ \_____\       \
                   /__________________\ \_____________\
                   \___________________\ \____________/
                                        \ \_-_-_-.
                                      /|         |
                                     |  |        |
                                       \         |
                                        \_______/

                   Chrome OS verification is turned off.
                     Press space to begin recovery.
  ' >"$STDOUT"
  # TODO(wad) Use the developer mode firmware image

  # Read a space bar or Ctrl+D or timeout.
  local input=$(match_char_timeout "$delay_secs" 04 20 < "$STDOUT")
  local exit_code=$?
  tput clear > "$STDOUT"
  # If we timed out, we're done.
  [ $exit_code -ne 0 ] && return 0
  case "$input" in
    "04")  # Ctrl+D
      # Done.
      ;;
    "20")  # Spacebar
      crossystem recovery_request=1
      reboot
      # To prevent system continue booting
      sleep 1d
      ;;
  esac
  return 0
}


# Prints message when entering developer mode
# Argument: time to countdown (in seconds)
mode_enter_dev() {
  local delay_secs="${1:-30}"
  show_assets_message_image "enter_dev1" ||
  # The text by echo below is only fallback of localized assets message.
  # Please sync with text there if you want to change the message.
  echo "
    Your system is transitioning to Developer Mode.
    Local data will be cleared.

    To cancel, turn your computer off now and
    toggle the developer switch back to Normal (Verified) Mode.
  " >"$STDOUT"

  local format='\r  %-30s'
  for dev_count_down in $(seq $delay_secs -1 1); do
    # Trailing spaces must exist to clear previous message when the printed
    # counter width changed (ex, 100->99).
    # TODO(hungte) merge this with assets messages so it can be localized.
    printf "$format" "Starting in $dev_count_down second(s)..." >"$STDOUT"
    sleep 1
  done

  # Count-down
  tput clear >"$STDOUT" &&
  show_assets_message_image "enter_dev2" ||
  # The text by echo below is only fallback of localized assets message.
  # Please sync with text there if you want to change the message.
  echo "
    Preparing system for Developer Mode (may take 5 - 10 minutes).
    Do not turn your computer off until it has restarted.

    On reboot, press Ctrl+Alt+[->] (F2) for information about Developer Mode.
  " >"$STDOUT"
  # TODO(wad,wfrichar) Request a root password here.
  # TODO(wad,reinauer) Inform the user of chromeos-firmwareupdate --mode=todev
}

# Prints message when leaving developer mode
mode_leave_dev() {
  show_assets_message_image "leave_dev" ||
  # The text by echo below is only fallback of localized assets message.
  # Please sync with text there if you want to change the message.
  echo "
    Your system last booted in Developer Mode.
    Returning to Normal (Verified) Mode...
    Upon completion, the system will reboot.
  " >"$STDOUT"
}

# Prints messages before starting firmware update
mode_update_firmware() {
  show_assets_message_image "update_firmware" ||
  # The text by echo below is only fallback of localized assets message.
  # Please sync with text there if you want to change the message.
  echo "
    Your system is applying a critical update.
    Please do not turn it off.
  " >"$STDOUT"
}

# Prints message before starting to erase stateful partition (wipe).
# Argument: (optional) file for splash image to show
mode_wipe() {
  local splash_file="$1"

  if [ -s "$splash_file" ] && type ply-image >/dev/null 2>&1; then
    # Do not use background execution because this file is going to be wiped.
    ply-image "$splash_file"
  else
    echo "    Erasing stateful partition..." >"$STDOUT"
  fi
}

# Prints message before starting to rebuild a corrupted stateful partition.
mode_self_repair() {
  show_assets_message_image "self_repair" ||
  # The text by echo below is only fallback of localized assets message.
  # Please sync with text there if you want to change the message.
  echo "
    Your system is repairing itself.  Please wait.
  " >"$STDOUT"
}

# Prints message when starting with developer firmware, to check if there's
# available updates for firmware.
mode_dev_fwcheck() {
  # TODO(hungte) Find some better way to store firmware value, like using
  # /etc/lsb-release.  Currently the firmware updater may contain fields like
  # TARGET_* in the beginning of updater script.
  local TARGET_FWID=""
  local TARGET_ECID=""
  # The magic value 40 is verified on current updaters (using line 23-24)
  eval "$(head -40 /usr/sbin/chromeos-firmwareupdate |
          grep '^ *TARGET_..ID=')"
  if [ -z "$TARGET_FWID" -a -z "$TARGET_ECID" ]; then
    return
  fi

  local fwid="$(crossystem fwid)"
  local ec_info
  ec_info="$(mosys -k ec info 2>/dev/null)" || ec_info=""
  local ecid="$(fw_version="Unknown"; eval "$ec_info"; echo "$fw_version")"

  # Ignore known firmware images carried by updaters with multiple images
  # TODO(hungte) Replace this by a "compatible list" in updater if such request
  # becomes a common feature.
  case "$(mosys platform name 2>/dev/null):$ecid" in
    "ZGB:0.14" | "Alex:00VFA616 " )
      TARGET_ECID="$ecid"
      ;;
  esac

  local notify_update=0
  if [ "$TARGET_FWID" != "$fwid" ] &&
     [ "$TARGET_FWID" != "IGNORE" ]; then
    notify_update=1
    echo "
      System firmware update available: [$TARGET_FWID]
      Currently installed system firmware: [$fwid]
    " >"$STDOUT"
  fi
  if [ "$TARGET_ECID" != "$ecid" ] &&
     [ "$TARGET_ECID" != "IGNORE" ]; then
    notify_update=1
    echo "
      EC firmware update available: [$TARGET_ECID]
      Currently installed EC firmware: [$ecid]
    " >"$STDOUT"
  fi
  if [ $notify_update -ne 0 ]; then
    echo "
      Firmware auto updating is disabled for developer mode. If you want to
      manually update your firmware, please run the following command from a
      root shell:

      sudo chromeos-firmwareupdate --force --mode=recovery
    " >"$STDOUT"
  fi
}

# Main initialization and dispatcher
main() {
  # process args
  if [ $# -lt 2 ]; then
    usage_help
    exit 1
  fi
  local mode="$1"
  # global
  STDOUT="$2"
  shift
  shift

  # light-up the screen if possible
  if [ -x /usr/sbin/lightup_screen ]; then
    /usr/sbin/lightup_screen >/dev/null 2>&1
  fi

  case "$mode" in
    "warn_dev" | "enter_dev" | "leave_dev" | "dev_fwcheck" | \
      "update_firmware" | "wipe" | "self_repair" )
      mode_"$mode" "$@"
      ;;
    * )
      usage_help
      exit 1
      ;;
  esac
}

# Main Entry
main "$@"
