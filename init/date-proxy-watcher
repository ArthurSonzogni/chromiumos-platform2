#!/bin/sh
# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

LOG="logger -t $UPSTART_JOB"

WORK_DIR="$1"

# Libcros D-Bus interface
DEST=org.chromium.LibCrosService
CROS_PATH=/org/chromium/LibCrosService
IFACE=${DEST}Interface
RESOLVE=${IFACE}.ResolveNetworkProxy
# shill network event D-Bus interface
SHILL_IFACE=org.chromium.flimflam.Manager
SHILL_FILTER="interface=${SHILL_IFACE},member=PropertyChanged"
# Custom interface to receive proxy configuration
RCV_IFACE=org.chromium.ProxyInterface
RCV_EVENT=ProxyChange
RCV_FILTER="interface=${RCV_IFACE},type=signal,member=${RCV_EVENT}"


URL="https://clients3.google.com"
proxy=""
proxy_current=""

$LOG "Start monitoring proxy changes in $WORK_DIR"

request_proxy() {
  # the browser interface gives a wrong answer (specifically, the proxy from
  # before the update) if asked immediately. We can afford to wait quite a while
  # before we restart tlsdated; in the worst case, we fail to fetch dates this
  # time. This doesn't affect boot time, where tlsdate runs anyway whether or
  # not there's a proxy set.
  sleep 30
  # Ask the browser to give us the proxy to use to access URL
  dbus-send --system --type=method_call --dest=${DEST} ${CROS_PATH} \
    ${RESOLVE} string:${URL} string:${RCV_IFACE} string:${RCV_EVENT}
}

monitor_net_change() {
  # request initial settings
  $LOG "monitor starting... $$"
  request_proxy
  dbus-monitor --system "${SHILL_FILTER}" |
    grep --line-buffered -o "Default[A-Za-z]*" |
    while read UNUSED_EVENT ; do
      # check proxy on each connectivity change
      request_proxy
    done
}

monitor_proxy_change() {
  # listen for responses to our proxy-request signal; when we get a response,
  # send it to stdout.
  dbus-monitor --system "${RCV_FILTER}" |
    grep --line-buffered -o -e DIRECT -e "PROXY [a-zA-Z0-9\-\.]\+:[0-9]\+"
}

mkfifo -m 600 "$WORK_DIR/proxy-fifo"

# We need to be listening for the proxy change response before request_proxy
# (above) is called, so we start the proxy change monitor before starting the
# net change monitor. If we don't do this, then we can miss the response to the
# initial proxy request and never set a proxy until the first proxy change
# event.
monitor_proxy_change > "$WORK_DIR/proxy-fifo" &
MON_PID="$!"

monitor_net_change &
NET_PID="$!"

trap "kill -TERM $MON_PID $NET_PID" EXIT INT QUIT TERM

(while read PROXY_SETTINGS < "$WORK_DIR/proxy-fifo" ; do
  case "${PROXY_SETTINGS}" in
    DIRECT )
      $LOG "direct connection"
      proxy="none"
      ;;
    PROXY* )
      $LOG "proxy ${PROXY_SETTINGS}"
      proxy="${PROXY_SETTINGS#PROXY }"
      ;;
  esac
  if [ "${proxy}" != "${proxy_current}" ]; then
    $LOG "proxy changing to '${proxy}'"
    echo "${proxy}"
    proxy_current=${proxy}
  fi
  done) >"$WORK_DIR/fifo"
