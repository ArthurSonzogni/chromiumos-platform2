// Copyright 2016 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "crash-reporter/core-collector/coredump_writer.h"

#include <sysexits.h>

#include <algorithm>

#include <base/format_macros.h>
#include <base/logging.h>
#include <base/sys_info.h>
#include <brillo/streams/file_stream.h>

#include <common/linux/elf_core_dump.h>

using brillo::ErrorPtr;
using brillo::FileStream;
using brillo::Stream;
using brillo::StreamPtr;

using google_breakpad::ElfCoreDump;

namespace {

const size_t kMaxAbsCoredumpSize = 256 * 1024 * 1024;
const double kMaxRelCoredumpSize = 0.05;  // Percentage of free disk space.

inline std::ostream &operator <<(std::ostream &out, const ErrorPtr &error) {
  return out << ": " << error->GetMessage();
}

}  // namespace

class CoredumpWriter::Reader {
 public:
  explicit Reader(Stream *src) : src_(src) {}

  bool Read(void *buf, size_t count, ErrorPtr *error) {
    if (!src_->ReadAllBlocking(buf, count, error))
      return false;
    bytes_read_ += count;
    return true;
  }

  bool CopyTo(Stream *dest, size_t count, ErrorPtr *error) {
    static const size_t kBufSize = 32 * 1024;
    char buf[kBufSize];
    while (count > 0) {
      size_t read;
      if (!src_->ReadBlocking(buf, std::min(kBufSize, count), &read, error))
        return false;
      if (read == 0)
        break;
      if (dest && !dest->WriteAllBlocking(buf, read, error))
        return false;
      count -= read;
      bytes_read_ += read;
    }
    return count == 0;
  }

  bool Seek(size_t offset, ErrorPtr *error) {
    if (offset < bytes_read_)  // Cannot move backward.
      return false;
    return CopyTo(nullptr, offset - bytes_read_, error);
  }

 private:
  Stream * const src_;
  size_t bytes_read_ = 0;

  DISALLOW_COPY_AND_ASSIGN(Reader);
};

CoredumpWriter::CoredumpWriter(int fd,
                               const char *coredump_path,
                               const char *container_dir)
    : src_(FileStream::FromFileDescriptor(fd, false, &error_)),
      coredump_path_(coredump_path),
      container_dir_(container_dir) {
}

int CoredumpWriter::WriteCoredump() {
  if (!src_) {
    LOG(ERROR) << "Failed to create stream" << error_;
    return EX_OSERR;
  }
  const StreamPtr dest = FileStream::Open(
      coredump_path_, FileStream::AccessMode::WRITE,
      FileStream::Disposition::CREATE_ALWAYS, &error_);
  if (!dest) {
    LOG(ERROR) << "Failed to open " << coredump_path_.value() << error_;
    return EX_CANTCREAT;
  }

  // Input core dump is generated by kernel's fs/binfmt_elf.c using this format:
  //
  //   ELF Header
  //   Program Header 1
  //   Program Header 2
  //   ...
  //   Program Header n
  //   Segment 1 (This segment's type should be PT_NOTE)
  //   Segment 2
  //   ...
  //   Segment n

  // Read ELF header, all program headers, and the first segment whose type is
  // PT_NOTE.
  Reader reader(src_.get());
  Ehdr elf_header;
  std::vector<Phdr> program_headers;
  std::vector<char> note_buf;
  int error = ReadUntilNote(&reader, &elf_header, &program_headers, &note_buf);
  if (error != EX_OK)
    return error;

  // Get a set of address ranges occupied by mapped files from PT_NOTE segment.
  FileMappings file_mappings;
  if (!GetFileMappings(note_buf, &file_mappings))
    return EX_OSFILE;

  // Strip segments backed by mapped files, since they are not needed to
  // generate a minidump.
  std::vector<Phdr> stripped_program_headers;
  StripSegments(program_headers, file_mappings, &stripped_program_headers);

  // Calculate the core dump size limit.
  const auto free_disk_space =
      base::SysInfo::AmountOfFreeDiskSpace(coredump_path_);
  if (free_disk_space < 0)
    return EX_OSERR;
  const auto coredump_size_limit = std::min(kMaxAbsCoredumpSize,
      static_cast<size_t>(free_disk_space * kMaxRelCoredumpSize));

  // Calculate the output file size.
  const auto &last = stripped_program_headers.back();
  const auto expected_coredump_size = last.p_offset + last.p_filesz;
  if (expected_coredump_size > coredump_size_limit) {
    LOG(ERROR) << "Core dump size is too large: " << expected_coredump_size;
    return EX_CANTCREAT;
  }

  // Write /proc files.
  error = WriteAuxv(note_buf);
  if (error != EX_OK) {
    LOG(ERROR) << "Failed to write auxv" << error_;
    return error;
  }
  error = WriteMaps(program_headers, file_mappings);
  if (error != EX_OK) {
    LOG(ERROR) << "Failed to write maps" << error_;
    return error;
  }

  // Write ELF header.
  if (!dest->WriteAllBlocking(&elf_header, sizeof(elf_header), &error_)) {
    LOG(ERROR) << "Failed to write ELF header" << error_;
    return EX_IOERR;
  }

  // Write program headers.
  for (size_t i = 0; i < stripped_program_headers.size(); ++i) {
    const Phdr &program_header = stripped_program_headers[i];
    const auto offset = sizeof(elf_header) + i * elf_header.e_phentsize;
    if (!dest->SetPosition(offset, &error_) ||
        !dest->WriteAllBlocking(
            &program_header, sizeof(program_header), &error_)) {
      LOG(ERROR) << "Failed to write program header" << error_;
      return EX_IOERR;
    }
  }

  // Write PT_NOTE segment.
  if (!dest->SetPosition(stripped_program_headers[0].p_offset, &error_) ||
      !dest->WriteAllBlocking(note_buf.data(), note_buf.size(), &error_)) {
    LOG(ERROR) << "Failed to write PT_NOTE segment" << error_;
    return EX_IOERR;
  }

  // Write segments that were not stripped.
  for (size_t i = 1; i < stripped_program_headers.size(); ++i) {
    const Phdr &program_header = stripped_program_headers[i];
    if (program_header.p_filesz == 0)
      continue;
    const Phdr &program_header_original = program_headers[i];
    if (!reader.Seek(program_header_original.p_offset, &error_)) {
      LOG(ERROR) << "Failed to seek segment" << error_;
      return EX_IOERR;
    }
    if (!dest->SetPosition(program_header.p_offset, &error_) ||
        !reader.CopyTo(dest.get(), program_header.p_filesz, &error_)) {
      LOG(ERROR) << "Failed to write segment" << error_;
      return EX_IOERR;
    }
  }

  return EX_OK;
}

int CoredumpWriter::ReadUntilNote(Reader *reader,
                                  Ehdr *elf_header,
                                  std::vector<Phdr> *program_headers,
                                  std::vector<char> *note_buf) {
  // Read ELF header.
  if (!reader->Read(elf_header, sizeof(*elf_header), &error_)) {
    LOG(ERROR) << "Failed to read ELF header" << error_;
    return EX_IOERR;
  }
  if (memcmp(elf_header->e_ident, ELFMAG, SELFMAG) != 0 ||
      elf_header->e_ident[EI_CLASS] != ElfCoreDump::kClass ||
      elf_header->e_version != EV_CURRENT ||
      elf_header->e_type != ET_CORE ||
      elf_header->e_ehsize != sizeof(Ehdr) ||
      elf_header->e_phentsize != sizeof(Phdr)) {
    LOG(ERROR) << "Invalid ELF header" << error_;
    return EX_OSFILE;
  }

  // Read program headers.
  program_headers->resize(elf_header->e_phnum);
  if (!reader->Seek(elf_header->e_phoff, &error_) ||
      !reader->Read(program_headers->data(),
                    sizeof(Phdr) * program_headers->size(), &error_)) {
    LOG(ERROR) << "Failed to read program headers" << error_;
    return EX_IOERR;
  }

  // The first segment should have type PT_NOTE. This assumption hinges on the
  // kernel's fs/binfmt_elf.c implementation.
  if (program_headers->empty() || (*program_headers)[0].p_type != PT_NOTE) {
    LOG(ERROR) << "Failed to locate PT_NOTE segment.";
    return EX_OSFILE;
  }
  const Phdr &note_program_header = (*program_headers)[0];

  // Read PT_NOTE segment.
  note_buf->resize(note_program_header.p_filesz);
  if (!reader->Seek(note_program_header.p_offset, &error_) ||
      !reader->Read(note_buf->data(), note_buf->size(), &error_)) {
    LOG(ERROR) << "Failed to read PT_NOTE segment" << error_;
    return EX_IOERR;
  }

  return EX_OK;
}

bool CoredumpWriter::GetFileMappings(const std::vector<char> &note_buf,
                                     FileMappings *file_mappings) {
  // Locate NT_FILE note.
  ElfCoreDump::Note note({ note_buf.data(), note_buf.size() });
  while (note.IsValid() && note.GetType() != NT_FILE)
    note = note.GetNextNote();

  if (!note.IsValid()) {
    LOG(ERROR) << "Failed to locate NT_FILE note.";
    return false;
  }
  const auto note_desc = note.GetDescription();

  // The NT_FILE note is generated by the kernel's fs/binfmt_elf.c as a
  // sequence of long values, followed by a sequence of char values.
  struct FileNote {
    ElfW(Off) count;
    ElfW(Off) page_size;

    struct {
      ElfW(Addr) start;
      ElfW(Addr) end;
      ElfW(Off) offset;
    } files[1];

    // The |files| array has |count| elements. The file paths are stored after
    // the array, as |count| null-terminated strings.
  };
  const FileNote *file_note =
      reinterpret_cast<const FileNote *>(note_desc.data());
  const size_t num_files = file_note->count;
  const char *path =
      reinterpret_cast<const char *>(&file_note->files[num_files]);

  // Populate file mappings.
  for (size_t i = 0; i < num_files; ++i) {
    const auto file = &file_note->files[i];
    const auto it = file_mappings->insert({
        FileRange(file->start, file->end),
        { file->offset * file_note->page_size, path }
    });
    // Skip past NUL to next path.
    path += it.first->second.path.length() + 1;
  }
  // The last path should end the note.
  if (path != reinterpret_cast<const char *>(file_note) + note_desc.length()) {
    LOG(ERROR) << "Invalid NT_FILE note.";
    return false;
  }
  return true;
}

void CoredumpWriter::StripSegments(
    const std::vector<Phdr> &program_headers,
    const FileMappings &file_mappings,
    std::vector<Phdr> *stripped_program_headers) {
  stripped_program_headers->resize(program_headers.size());

  // The first segment has type PT_NOTE. Use the original data unchanged.
  (*stripped_program_headers)[0] = program_headers[0];

  for (size_t i = 1; i < program_headers.size(); ++i) {
    Phdr &out = (*stripped_program_headers)[i];
    out = program_headers[i];

    // If the type is PT_LOAD and the range is found in the set, the segment is
    // backed by a file, so it can be excluded as it doesn't contain stack data
    // useful to generate a minidump.
    const FileRange range(out.p_vaddr, out.p_vaddr + out.p_memsz);
    if (out.p_type == PT_LOAD && file_mappings.count(range))
      out.p_filesz = 0;

    // Calculate offset.
    const Phdr &prev_program_header = (*stripped_program_headers)[i - 1];
    out.p_offset = prev_program_header.p_offset + prev_program_header.p_filesz;
    // Offset alignment.
    if (out.p_align != 0 && out.p_offset % out.p_align != 0)
      out.p_offset += out.p_align - out.p_offset % out.p_align;
  }
}

int CoredumpWriter::WriteAuxv(const std::vector<char> &note_buf) {
  // Locate NT_AUXV note.
  ElfCoreDump::Note note({ note_buf.data(), note_buf.size() });
  while (note.IsValid() && note.GetType() != NT_AUXV)
    note = note.GetNextNote();

  if (!note.IsValid()) {
    LOG(ERROR) << "Failed to locate NT_AUXV note.";
    return EX_OSFILE;
  }

  const auto path = container_dir_.Append("auxv");
  const StreamPtr auxv = FileStream::Open(
      path, FileStream::AccessMode::WRITE,
      FileStream::Disposition::CREATE_ALWAYS, &error_);
  if (!auxv) {
    LOG(ERROR) << "Failed to open " << path.value() << error_;
    return EX_CANTCREAT;
  }
  // The NT_AUXV note has the same format as /proc/[pid]/auxv.
  const auto desc = note.GetDescription();
  return auxv->WriteAllBlocking(
      desc.data(), desc.length(), &error_) ? EX_OK : EX_IOERR;
}

int CoredumpWriter::WriteMaps(const std::vector<Phdr> &program_headers,
                              const FileMappings &file_mappings) {
  const auto path = container_dir_.Append("maps");
  const StreamPtr maps = FileStream::Open(
      path, FileStream::AccessMode::WRITE,
      FileStream::Disposition::CREATE_ALWAYS, &error_);

  if (!maps) {
    LOG(ERROR) << "Failed to open " << path.value() << error_;
    return EX_CANTCREAT;
  }

  for (const auto &program_header : program_headers) {
    if (program_header.p_type != PT_LOAD)
      continue;
    const FileRange range(program_header.p_vaddr,
                          program_header.p_vaddr + program_header.p_memsz);
    // If a mapping is found for the range, the range is mapped to a file.
    const auto it = file_mappings.find(range);
    const ElfW(Off) offset = it != file_mappings.end() ? it->second.offset : 0;
    const auto path = it != file_mappings.end() ? it->second.path.c_str() : "";

    const int kBufSize = 1024;
    char buf[kBufSize];
    // See kernel's fs/proc/task_{no,}mmu.c for format string.
    const int len = snprintf(
        buf, kBufSize,
        "%08" PRIxPTR
        "-"
        "%08" PRIxPTR
        " %c%c%c%c"
        " %08" PRIx64
        " %02x:%02x %lu %s\n",
        range.first, range.second,
        program_header.p_flags & PF_R ? 'r' : '-',
        program_header.p_flags & PF_W ? 'w' : '-',
        program_header.p_flags & PF_X ? 'x' : '-',
        'p',  // Fake value: we can't know if the mapping is shared or private.
        static_cast<uint64_t>(offset),
        0,  // Fake device (major) value.
        0,  // Fake device (minor) value.
        0ul,  // Fake inode value.
        path);
    if (len < 0 || len >= kBufSize ||
        !maps->WriteAllBlocking(buf, len, &error_))
      return EX_OSFILE;
  }

  return EX_OK;
}
