# Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

description   "Chrome OS user interface"
author        "chromium-os-dev@chromium.org"

# Note, the 'start on' line is modified by the chromeos-factoryinstall
# ebuild.  Please do not change it without also changing that
# reference.
#
# This job's post-stop script depends on cryptohomed being running;
# cryptohomed in turn depends on chapsd and dbus-daemon.  This job's
# stop condition uses a special stop job to keep those processes
# from terminating until after this job has cleaned up.  See the
# pre-shutdown job for more details.
# NB: Respawning is now handled by ui-respawn.conf, as the logic is
# more complex than upstart was designed to handle.
start on started boot-services
stop on starting pre-shutdown

# Enables chrome to renice background tabs (lower priority), and to set the
# priority of realtime threads to real time.
limit nice 20 20
limit rtprio 10 10

# Extend the grace period given to the session_manager before upstart decides
# it's gone unresponsive on job termination and must be killed. Chrome gets 12s
# (configured below) to shut down on devices with HDDs, so give a cushion.
kill timeout 20  # In seconds.

# Uncomment line below to output to VT02
#console output

# Directory where session manager logs are written and prefix of files there.
env UI_LOG_DIR=/var/log/ui
env UI_LOG_FILE=ui.LATEST

pre-start script
  mkdir -p $UI_LOG_DIR
  ln -sf ui.$(date +%Y%m%d-%H%M%S) $UI_LOG_DIR/$UI_LOG_FILE

  # Set up cgroups for chrome. We create two task groups, one for at most one
  # foreground renderer and one for all the background renderers and set the
  # background group to a very low priority. We specifically do not set it to
  # the lowest "2" such that other processes like the update-engine can be even
  # lower. The default value is 1024.
  CHROME_CGROUP_DIR=/sys/fs/cgroup/cpu/chrome_renderers
  if [ ! -d $CHROME_CGROUP_DIR ]; then
    mkdir -p ${CHROME_CGROUP_DIR}/foreground
    mkdir -p ${CHROME_CGROUP_DIR}/background
    echo "10" > ${CHROME_CGROUP_DIR}/background/cpu.shares
    chown -R chronos ${CHROME_CGROUP_DIR}
  fi
end script  # pre-start

script
  # The session_manager supports pinging the browser periodically to check that
  # it is still alive.  On developer systems, this would be a problem, as
  # debugging the browser would cause it to be aborted. Override via a flag-file
  # is allowed to enable integration testing.
  HANG_DETECTION_FLAG_FILE=/var/run/session_manager/enable_hang_detection
  HANG_DETECTION_FLAG=
  if ! is_developer_end_user; then
    HANG_DETECTION_FLAG="--enable-hang-detection"
  elif [ -f ${HANG_DETECTION_FLAG_FILE} ]; then
    HANG_DETECTION_FLAG="--enable-hang-detection=5"  # And do it FASTER!
  fi

  # On platforms with rotational disks, Chrome takes longer to shut down. As
  # such, we need to change our baseline assumption about what "taking too long
  # to shutdown" means and wait for longer before killing Chrome and triggering
  # a report.
  # TODO(derat): Move this into the session_manager binary, maybe.
  ROOTDEV="$(rootdev -s -d | sed -e 's/^\/dev\///')"
  KILL_TIMEOUT_FLAG=
  if [ "$(cat /sys/block/${ROOTDEV}/queue/rotational)" = 1 ]; then
    KILL_TIMEOUT_FLAG="--kill-timeout=12"
  fi

  exec session_manager \
    $HANG_DETECTION_FLAG \
    $KILL_TIMEOUT_FLAG \
    >$UI_LOG_DIR/$UI_LOG_FILE 2>&1
end script

post-stop script
  bootstat ui-post-stop
  set +e
  . /sbin/killers

  # Terminate PKCS #11 services.
  cryptohome --action=pkcs11_terminate

  # Terminate any processes with files open on the mount point
  # TODO(wad) parallelize with VFS/PID namespaces.
  kill_with_open_files_on /home/chronos/u-*

  # Make sure everything is going down. No exceptions.
  # The loop is so that clever daemons can't evade the kill by
  # racing us and killing us first; we'll just try over and over
  # until we win the race, and kill with pid -1 is atomic with
  # respect to process creation.
  while ! sudo -u chronos kill -9 -- -1 ; do
    sleep .1
  done

  # Check for still-living chronos processes and log their status.
  ps -u chronos --no-headers -o pid,stat,args |
    logger -i -t "${UPSTART_JOB}-unkillable" -p crit

  bootstat other-processes-terminated

  term_process '^X$'
  bootstat x-terminated

  cryptohome --action=unmount
  bootstat cryptohome-unmounted
end script
