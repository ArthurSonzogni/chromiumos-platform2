// Copyright 2016 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "authpolicy/policy/user_policy_encoder.h"

#include <string>
#include <vector>

#include "base/strings/string_number_conversions.h"
#include "base/values.h"

#include "authpolicy/policy/policy_encoder_helper.h"
#include "authpolicy/policy/proto/cloud_policy.pb.h"
#include "authpolicy/policy/registry_dict.h"

namespace em = enterprise_management;

namespace policy {

void UserPolicyEncoder::EncodeUserPolicy(
    em::CloudPolicySettings* policy) const {
  // Note: UserPolicyEncoder::EncodeUserPolicy{1,2} is autogenerated, see
  // user_policy_encoder_gen.cc.
  EncodeUserPolicy1(policy);
  EncodeUserPolicy2(policy);
}

void UserPolicyEncoder::SetPolicyOptions(em::PolicyOptions* options) const {
  DCHECK(options);
  options->set_mode(level_ == POLICY_LEVEL_RECOMMENDED
                        ? em::PolicyOptions_PolicyMode_RECOMMENDED
                        : em::PolicyOptions_PolicyMode_MANDATORY);
}

const char* UserPolicyEncoder::GetLevelStr() const {
  return level_ == POLICY_LEVEL_RECOMMENDED ? "Recommended" : "Mandatory";
}

void UserPolicyEncoder::EncodeBoolean(
    const char* policy_name, const BooleanPolicyCallback& create_proto) const {
  // Try to get policy value from dict.
  const base::Value* value = dict_->GetValue(policy_name);
  if (!value)
    return;

  // Get actual value, doing type conversion if necessary.
  bool bool_value;
  if (!helper::GetAsBoolean(value, &bool_value)) {
    helper::PrintConversionError(value, "boolean", policy_name);
    return;
  }

  LOG(INFO) << GetLevelStr() << " bool " << policy_name << " = "
            << (bool_value ? "true" : "false");

  // Create proto and set value.
  em::BooleanPolicyProto* proto = create_proto.Run();
  DCHECK(proto);
  proto->set_value(bool_value);
  SetPolicyOptions(proto->mutable_policy_options());
}

void UserPolicyEncoder::EncodeInteger(
    const char* policy_name, const IntegerPolicyCallback& create_proto) const {
  // Try to get policy value from dict.
  const base::Value* value = dict_->GetValue(policy_name);
  if (!value)
    return;

  // Get actual value, doing type conversion if necessary.
  int int_value;
  if (!helper::GetAsInteger(value, &int_value)) {
    helper::PrintConversionError(value, "integer", policy_name);
    return;
  }

  LOG(INFO) << GetLevelStr() << " int " << policy_name << " = " << int_value;

  // Create proto and set value.
  em::IntegerPolicyProto* proto = create_proto.Run();
  DCHECK(proto);
  proto->set_value(int_value);
  SetPolicyOptions(proto->mutable_policy_options());
}

void UserPolicyEncoder::EncodeString(
    const char* policy_name, const StringPolicyCallback& create_proto) const {
  // Try to get policy value from dict.
  const base::Value* value = dict_->GetValue(policy_name);
  if (!value)
    return;

  // Get actual value, doing type conversion if necessary.
  std::string string_value;
  if (!helper::GetAsString(value, &string_value)) {
    helper::PrintConversionError(value, "string", policy_name);
    return;
  }

  LOG(INFO) << GetLevelStr() << " str " << policy_name << " = " << string_value;

  // Create proto and set value.
  em::StringPolicyProto* proto = create_proto.Run();
  DCHECK(proto);
  *proto->mutable_value() = string_value;
  SetPolicyOptions(proto->mutable_policy_options());
}

void UserPolicyEncoder::EncodeStringList(
    const char* policy_name,
    const StringListPolicyCallback& create_proto) const {
  // Try to get policy key from dict.
  const RegistryDict* key = dict_->GetKey(policy_name);
  if (!key)
    return;

  // Get and check all values. Do this in advance to prevent partial writes.
  std::vector<std::string> string_values;
  for (int index = 0; /* empty */; ++index) {
    std::string indexStr = base::IntToString(index + 1);
    const base::Value* value = key->GetValue(indexStr);
    if (!value)
      break;

    std::string string_value;
    if (!helper::GetAsString(value, &string_value)) {
      helper::PrintConversionError(value, "string", policy_name);
      return;
    }

    string_values.push_back(string_value);
  }

  LOG(INFO) << GetLevelStr() << " strlist " << policy_name;
  for (const std::string& value : string_values)
    LOG(INFO) << "  " << value;

  // Create proto and set value.
  em::StringListPolicyProto* proto = create_proto.Run();
  DCHECK(proto);
  em::StringList* proto_list = proto->mutable_value();
  DCHECK(proto_list);
  for (const std::string& value : string_values)
    *proto_list->add_entries() = value;
  SetPolicyOptions(proto->mutable_policy_options());
}

}  // namespace policy
