// Copyright 2021 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <memory>
#include <utility>

#include <base/run_loop.h>
#include <base/task/single_thread_task_runner.h>
#include <base/test/bind.h>
#include <base/test/task_environment.h>
#include <gtest/gtest.h>
#include <mojo/core/embedder/embedder.h>
#include <mojo/core/embedder/scoped_ipc_support.h>
#include <mojo/public/cpp/bindings/receiver.h>
#include <mojo/public/cpp/bindings/receiver_set.h>
#include <mojo/public/cpp/bindings/remote.h>

#include "diagnostics/bindings/connectivity/context.h"
#include "diagnostics/bindings/connectivity/local_state.h"
#include "diagnostics/bindings/connectivity/remote_state.h"
#include "diagnostics/bindings/connectivity/test/test_client.mojom-connectivity.h"
#include "diagnostics/bindings/connectivity/test/test_common.mojom-connectivity.h"
#include "diagnostics/bindings/connectivity/test/test_server.mojom-connectivity.h"

namespace ash::cros_healthd::connectivity::test {
namespace {

class MojoConnectivityTest : public ::testing::Test {
 protected:
  void SetUp() override {
    ::mojo::core::Init();
    ipc_support_ = std::make_unique<::mojo::core::ScopedIPCSupport>(
        base::SingleThreadTaskRunner::
            GetCurrentDefault() /* io_thread_task_runner */,
        ::mojo::core::ScopedIPCSupport::ShutdownPolicy::
            CLEAN /* blocking shutdown */);

    mojo::PendingReceiver<mojom::State> receiver;
    auto remote = receiver.InitWithNewPipeAndPassRemote();
    context_ = Context::Create(LocalState::Create(std::move(receiver)),
                               RemoteState::Create(std::move(remote)));
  }

  Context* context() { return context_.get(); }

 private:
  base::test::SingleThreadTaskEnvironment task_environment_;
  std::unique_ptr<mojo::core::ScopedIPCSupport> ipc_support_;
  std::unique_ptr<Context> context_;
};

template <typename T>
int CountPossibleValues(T type) {
  int cnt = 0;
  while (type->HasNext()) {
    ++cnt;
    type->Generate();
  }
  return cnt;
}

TEST_F(MojoConnectivityTest, DataGenerator) {
  ASSERT_EQ(CountPossibleValues(
                server::mojom::TestSuccessTestProvider::Create(context())),
            1);
  ASSERT_EQ(CountPossibleValues(
                server::mojom::TestSuccessTestConsumer::Create(context())),
            1);
  ASSERT_EQ(CountPossibleValues(DataGenerator<int32_t>::Create(context())), 1);
  ASSERT_EQ(CountPossibleValues(DataGenerator<std::string>::Create(context())),
            1);
  ASSERT_EQ(
      CountPossibleValues(
          OptionalGenerator<DataGenerator<std::string>>::Create(context())),
      2);
  ASSERT_EQ(CountPossibleValues(HandleDataGenerator::Create(context())), 1);
  // Test struct generated by the bindings generator. The result is the maximum
  // possible value count of all the field.
  ASSERT_EQ(CountPossibleValues(
                server::mojom::MyStructDataGenerator::Create(context())),
            2);
  ASSERT_EQ(CountPossibleValues(
                NullableGenerator<server::mojom::MyStructDataGenerator>::Create(
                    context())),
            2 + 1 /*nullable*/);
  // Test union generated by the bindings generator. The result is the sum
  // of the size of each field. For example:
  // union MyUnion {
  //   int32 num;               -> 1
  //   string str;              -> 1
  //   string ? opt_str;        -> 2
  //   MyStruct my_struct;      -> 2
  //   MyStruct ? my_struct_opt;-> 3
  // };                         => 9
  ASSERT_EQ(CountPossibleValues(
                server::mojom::MyUnionDataGenerator::Create(context())),
            9);
  ASSERT_EQ(CountPossibleValues(
                NullableGenerator<server::mojom::MyUnionDataGenerator>::Create(
                    context())),
            9 + 1 /*nullable*/);
  ASSERT_EQ(CountPossibleValues(
                common::mojom::MyUnionDataGenerator::Create(context())),
            4);
  ASSERT_EQ(CountPossibleValues(
                NullableGenerator<common::mojom::MyUnionDataGenerator>::Create(
                    context())),
            4 + 1 /*nullable*/);
  // Test enum generated by the bindings generator. The result is the field
  // count.
  ASSERT_EQ(CountPossibleValues(
                server::mojom::MyEnumDataGenerator::Create(context())),
            3);
  ASSERT_EQ(CountPossibleValues(
                server::mojom::EnumWithDefaultDataGenerator::Create(context())),
            3);
  // Test array generated by the bindings generator. The array generator
  // generates an array contains all possible values.
  {
    auto arr = common::mojom::TestArr1DataGenerator::Create(context());
    ASSERT_TRUE(arr->HasNext());
    ASSERT_EQ(arr->Generate()->arr.size(), 4 /* all possible MyUnion */);
    ASSERT_FALSE(arr->HasNext());
  }
  {
    auto arr = common::mojom::TestArr2DataGenerator::Create(context());
    ASSERT_TRUE(arr->HasNext());
    ASSERT_EQ(arr->Generate()->arr.size(), 4 + 1 /* MyUnion? nullable */);
    ASSERT_FALSE(arr->HasNext());
  }
  ASSERT_EQ(CountPossibleValues(
                common::mojom::TestArr3DataGenerator::Create(context())),
            1 + 1 /* array<MyUnion>? nullable*/);
  // Test map generated by the bindings generator. The result is the maximum
  // possible value of key type and value type.
  ASSERT_EQ(CountPossibleValues(
                common::mojom::TestMap1DataGenerator::Create(context())),
            5 /* sizeof MyUnion? */);
  ASSERT_EQ(CountPossibleValues(
                common::mojom::TestMap2DataGenerator::Create(context())),
            5 /* sizeof MyUnion? */);
  ASSERT_EQ(CountPossibleValues(
                common::mojom::MapKeyDataGenerator::Create(context())),
            3);
  ASSERT_EQ(CountPossibleValues(
                common::mojom::TestMap3DataGenerator::Create(context())),
            3 /* sizeof MapKey */);
  ASSERT_EQ(CountPossibleValues(
                common::mojom::TestMap4DataGenerator::Create(context())),
            3 + 1 /*map<MapKey, int32>? nullable */);
  // Test custom type mapping data generator. This kind of generator will be
  // implemented by users.
  ASSERT_EQ(CountPossibleValues(
                common::mojom::TestTypeMappingDataGenerator::Create(context())),
            42);
}

template <typename ConsumerType>
bool Check(ConsumerType* consumer) {
  base::RunLoop run_loop;
  bool res;
  consumer->Check(base::BindLambdaForTesting([&](bool res_inner) {
    res = res_inner;
    run_loop.Quit();
  }));
  run_loop.Run();
  return res;
}

#define INTERFACE_TEST_BASE(INTERFACE_NAME)                              \
  auto provider =                                                        \
      server::mojom::INTERFACE_NAME##TestProvider::Create(context());    \
  ASSERT_NE(provider, nullptr);                                          \
  auto consumer =                                                        \
      client::mojom::INTERFACE_NAME##TestConsumer::Create(context());    \
  ASSERT_NE(consumer, nullptr);                                          \
  auto pending_receiver = consumer->Generate();                          \
  provider->Bind(::mojo::PendingReceiver<server::mojom::INTERFACE_NAME>( \
      pending_receiver.PassPipe()));

#define SUCCESSFUL_TEST(INTERFACE_NAME)          \
  TEST_F(MojoConnectivityTest, INTERFACE_NAME) { \
    INTERFACE_TEST_BASE(INTERFACE_NAME);         \
    EXPECT_TRUE(Check(consumer.get()));          \
  }

#define FAILED_TEST(INTERFACE_NAME)              \
  TEST_F(MojoConnectivityTest, INTERFACE_NAME) { \
    INTERFACE_TEST_BASE(INTERFACE_NAME);         \
    EXPECT_FALSE(Check(consumer.get()));         \
  }

SUCCESSFUL_TEST(TestSuccess);

FAILED_TEST(TestMissFunction);
FAILED_TEST(TestWrongFunctionType1);
FAILED_TEST(TestWrongFunctionType2);
FAILED_TEST(TestWrongType);
FAILED_TEST(TestWrongReturnType);
FAILED_TEST(TestCannotBeNull);
FAILED_TEST(TestWrongStruct);
FAILED_TEST(TestWrongUnion);
FAILED_TEST(TestFailSubInterfaceForward);
FAILED_TEST(TestFailSubInterfaceBackward);

}  // namespace
}  // namespace ash::cros_healthd::connectivity::test
