// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// API exposed by the cros_healthd daemon. This API is normally consumed by the
// browser and the telem and diag command-line tools.

// NOTE: This mojom should be kept in sync with the copy in Chromium's repo in
// src/chromeos/ash/services/cros_healthd/public/mojom/cros_healthd_routines.mojom.

module ash.cros_healthd.mojom;

// Routines interface exposed by the cros_healthd daemon.
//
// NextMinVersion: 1, NextIndex: 1
interface CrosHealthdRoutinesService {
  // Requests that the a routine using the RoutineControl API is created on the
  // platform. This function creates different routine based on the
  // RoutineArgument supplied.
  //
  // The request:
  // * |routine_argument| - a RoutineArgument type that provides all the necessary
  //                        parameters and configs to create a particular type
  //                        of routine.
  // * |routine_receiver| - a receiver that will be bound to the actual routine
  //                        control implementation, where the remote will be
  //                        held by the client for starting the routine and
  //                        adding observer.
   CreateRoutine@0(RoutineArgument routine_argument,
    pending_receiver<RoutineControl> routine_receiver);
};

// Possible routines the RoutineControl API can create.
//
// NextMinVersion: 2, NextIndex: 2
[Extensible]
union RoutineArgument {
  // Default field is required by extensible unions for backward compatibility.
  // Any unrecognized Mojo field will deserialize to this field. Don't use this.
  [Default, MinVersion=1] bool unrecognizedArgument @0;

  // Arguments to create a memory routine.
  MemoryRoutineArgument memory@1;
};

// This routine checks whether there is any memory problem by
// reading/writing different patterns.
struct MemoryRoutineArgument {
  // An optional field to indicate how much memory should be tested. If the
  // value is null, memory test will run with as much memory as possible.
  uint32? max_testing_mem_kib;
};


// Interface exposed to clients for controlling a routine.
//
// NextMinVersion: 1, NextIndex: 3
interface RoutineControl {
  // Gets the current state of the routine.
  GetState@0() => (RoutineState state);

  // Sets an observer to receive the status update. It will only be called after
  // the routine has started.
  AddObserver@1(pending_remote<RoutineObserver> observer);

  // Starts the routine. No operation if the routine has already started.
  Start@2();
};

// Implemented by clients who desire routine update notifications.
//
// NextMinVersion: 1, NextIndex: 1
interface RoutineObserver {
  // Is called when the routine state has changed.
  OnRoutineStateChange@0(RoutineState state);
};

// Used to pass information regarding routine state.
//
// NextMinVersion: 1, NextIndex: 2
struct RoutineState {
  // The percentage of the completion of the routine. 0 to 100.
  uint8 percentage@0;

  RoutineStateUnion state_union@1;
};

// Possible routine states.
//
// NextMinVersion: 1, NextIndex: 4
union RoutineStateUnion {
  // Routine has been initialized but not yet started.
  RoutineStateInitialized initialized@0;
  // Routine is running.
  RoutineStateRunning running@1;
  // Routine is waiting for something.
  RoutineStateWaiting waiting@2;
  // Routine has finished.
  RoutineStateFinished finished@3;
};

// Routine has been initialized but not yet started.
//
// NextMinVersion: 1, NextIndex: 0
struct RoutineStateInitialized {};

// Routine is currently running.
//
// NextMinVersion: 1, NextIndex: 0
struct RoutineStateRunning {};

// Routine is currently waiting.
//
// NextMinVersion: 1, NextIndex: 2
struct RoutineStateWaiting {
  [Extensible]
  enum Reason {
    [Default] kUnmappedEnumField = 0,
    // Waiting for the job to be scheduled for running.
    kWaitingToBeScheduled = 1
  };
  // Reason for why the routine is waiting.
  Reason reason@0;
  // Message for why the routine is waiting, may be used to pass instruction or explanation.
  string message@1;
};

// Routine has finished.
//
// NextMinVersion: 1, NextIndex: 2
struct RoutineStateFinished {
  // Whether the routine has passed or not.
  bool has_passed@0;
  // The details of the routine.
  RoutineDetail? detail@1;
};

union RoutineDetail {
  MemoryRoutineDetail memory;
};

// Details regarding memory routine.
//
// NextMinVersion: 1, NextIndex: 2
struct MemoryRoutineDetail {
  // Number of bytes tested in the memory routine.
  uint64 bytes_tested@0;
  // Contains the memtester test results.
  MemtesterResult result@1;
};

// Enumeration of each possible memtester test item.
//
// NextMinVersion: 1, NextIndex: 20
[Extensible]
enum MemtesterTestItemEnum {
  [Default] kUnmappedEnumField = 0,
  // The memtester test is not recognized.
  kUnknown = 1,

  // Test that all memory addresses to be tested can be set to itself and its
  // complement.
  kStuckAddress = 2,

  // These tests test different operation of a random int64 with buffer
  // initialized as 0xFFFFFFFF, repeating over 64 bit blocks.
  // Perform AND operation.
  kCompareAND = 3,
  // Perform DIV operation.
  kCompareDIV = 4,
  // Perform MUL operation.
  kCompareMUL = 5,
  // Perform OR operation.
  kCompareOR = 6,
  // Perform SUB operation.
  kCompareSUB = 7,
  // Perform XOR operation.
  kCompareXOR = 8,
  // Perform ADD operation.
  kSequentialIncrement = 9,

  // These tests test setting memory regions in a certain pattern, repeating
  // over each 64 bit blocks.
  // Test Pattern: |0*10*| and |1*01*|.
  kBitFlip = 10,
  // Test Pattern:|0*1010*| and |1*0101*|.
  kBitSpread = 11,
  // Test Pattern: all 256 possible combinations of a 8 bit block, repeated 8
  // times.
  kBlockSequential = 12,
  // Test Pattern: Alternating 0 and 1.
  kCheckerboard = 13,
  // Test Pattern: Random 64 bits.
  kRandomValue = 14,
  // Test Pattern: all 0s and all 1s.
  kSolidBits = 15,
  // Test Pattern: |0*10*|.
  kWalkingOnes = 16,
  // Test Pattern: |1*01*|.
  kWalkingZeroes = 17,

  // These tests test writing random n bit words across the memory regions.
  // Test Pattern: 8 bit random words.
  k8BitWrites = 18,
  // Test Pattern: 16 bit random words.
  k16BitWrites = 19,
};

// Result from running memtester.
//
// NextMinVersion: 1, NextIndex: 2
struct MemtesterResult {
  // Tests that have passed.
  array<MemtesterTestItemEnum> passed_items@0;
  // Tests that have failed.
  array<MemtesterTestItemEnum> failed_items@1;
};


// This will be used as the disconnect reason of the RoutineControl interface
// when an exception occurs.
//
// NextMinVersion: 1, NextIndex: 4
[Extensible]
enum RoutineControlExceptionEnum{
  [Default] kUnmappedEnumField = 1,
  // This is the default value of the mojo disconnect reason.
  kMojoDisconnectWithoutReason = 0,
  // The routine is not supported on this device. RoutineControl raises this
  // error before any other methods are invoked.
  kNotSupported = 2,
  // Any other exceptions happen after creating the routine. E.g. No resource to
  // run the routine / the required device is currently unavailable.
  kRuntimeError = 3,
};
